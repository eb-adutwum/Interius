{"files": [{"path": "app/main.py", "content": "from fastapi import FastAPI, Request\nfrom fastapi.responses import JSONResponse\nfrom starlette.middleware.base import BaseHTTPMiddleware\nimport logging\nimport time\nimport traceback\n\nfrom sqlmodel import SQLModel\nfrom app.database import engine\nfrom app.routes import router as api_router\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(\"app.main\")\n\n\nclass AuditMiddleware(BaseHTTPMiddleware):\n    \"\"\"\n    Lightweight audit middleware that records basic request metadata.\n    It intentionally does not write to DB directly (AuditService is used by services/controllers),\n    but provides consistent request-level logging and timing which can be consumed by other middleware\n    or request handlers via request.state.\n    \"\"\"\n\n    async def dispatch(self, request: Request, call_next):\n        start = time.time()\n        # attach start time for potential downstream use\n        request.state.started_at = start\n        try:\n            response = await call_next(request)\n        except Exception as exc:\n            # Let the global exception handler deal with formatting, but log here as well.\n            logger.exception(\"Unhandled exception in request processing\")\n            raise\n\n        process_time = (time.time() - start) * 1000.0\n        client = request.client.host if request.client else None\n        logger.info(\n            \"%s %s %s %sms client=%s\",\n            request.method,\n            request.url.path,\n            response.status_code,\n            f\"{process_time:.2f}\",\n            client,\n        )\n        return response\n\n\ndef create_app() -> FastAPI:\n    app = FastAPI(title=\"Government Payroll System\")\n\n    # Register middleware\n    app.add_middleware(AuditMiddleware)\n\n    # Include API router from app.routes\n    app.include_router(api_router)\n\n    @app.get(\"/\", include_in_schema=False)\n    async def root():\n        return {\"message\": \"Government Payroll System API\"}\n\n    # Global exception handler for unexpected errors\n    @app.exception_handler(Exception)\n    async def global_exception_handler(request: Request, exc: Exception):\n        # Log full traceback server-side\n        tb = \"\".join(traceback.format_exception(type(exc), exc, exc.__traceback__))\n        logger.error(\"Unexpected error for request %s %s\\n%s\", request.method, request.url.path, tb)\n        return JSONResponse(\n            status_code=500,\n            content={\"detail\": \"Internal Server Error\"},\n        )\n\n    # Startup event to create DB tables\n    @app.on_event(\"startup\")\n    def on_startup():\n        logger.info(\"Creating database tables (if not exist)\")\n        SQLModel.metadata.create_all(engine)\n        logger.info(\"Database initialization complete\")\n\n    return app\n\n\napp = create_app()"}, {"path": "app/database.py", "content": "import os\nfrom typing import Generator, Optional\n\nfrom sqlmodel import SQLModel, Session, create_engine\nfrom sqlalchemy.orm import sessionmaker\n\n# Read database URL from environment, default to a local SQLite file for convenience.\nDATABASE_URL: str = os.getenv(\"DATABASE_URL\", \"sqlite:///./test.db\")\nSQLMODEL_ECHO = os.getenv(\"SQLMODEL_ECHO\", \"false\").lower() == \"true\"\n\ndef _create_engine(database_url: Optional[str] = None):\n    \"\"\"\n    Create and return a SQLModel engine. Applies SQLite-specific connect args when needed.\n    \"\"\"\n    url = database_url or DATABASE_URL\n    connect_args = {}\n    if url.startswith(\"sqlite\"):\n        # SQLite in multithreaded apps requires this flag\n        connect_args = {\"check_same_thread\": False}\n    return create_engine(url, echo=SQLMODEL_ECHO, connect_args=connect_args)\n\n# Module-level engine and session factory\nengine = _create_engine()\nSessionLocal = sessionmaker(bind=engine, class_=Session, expire_on_commit=False)\n\n\ndef get_session() -> Generator[Session, None, None]:\n    \"\"\"\n    FastAPI dependency that yields a SQLModel Session and ensures it is closed.\n\n    Usage in path operations:\n        from app.database import get_session\n        def endpoint(session: Session = Depends(get_session)):\n            ...\n    \"\"\"\n    session: Session = SessionLocal()\n    try:\n        yield session\n    finally:\n        session.close()\n\n\ndef init_db(database_url: Optional[str] = None) -> None:\n    \"\"\"\n    Initialize the database by creating all tables for SQLModel models.\n    If database_url is provided, a temporary engine will be used to create tables.\n    \"\"\"\n    if database_url and database_url != DATABASE_URL:\n        tmp_engine = _create_engine(database_url)\n        SQLModel.metadata.create_all(tmp_engine)\n    else:\n        SQLModel.metadata.create_all(engine)"}, {"path": "app/models.py", "content": "from datetime import datetime, date\nfrom typing import Optional, List, Dict, Any\n\nfrom sqlmodel import SQLModel, Field, Relationship\nfrom sqlalchemy import Column, Integer, String, DateTime, Date, Float, Boolean, ForeignKey, JSON, LargeBinary, func, UniqueConstraint, Index\n\n\nclass User(SQLModel, table=True):\n    __tablename__ = \"users\"\n    __table_args__ = (\n        UniqueConstraint(\"username\", name=\"uq_users_username\"),\n        Index(\"ix_users_status\", \"status\"),\n    )\n\n    id: Optional[int] = Field(default=None, primary_key=True)\n    username: str = Field(sa_column=Column(String(length=150), nullable=False, unique=True))\n    password_hash: str = Field(sa_column=Column(String(length=255), nullable=False))\n    role: str = Field(sa_column=Column(String(length=50), nullable=False))  # e.g., payroll-admin, approver, hr, employee, auditor\n    employee_id: Optional[int] = Field(default=None, foreign_key=\"employees.id\", sa_column=Column(Integer, ForeignKey(\"employees.id\"), nullable=True))\n    last_login: Optional[datetime] = Field(default=None, sa_column=Column(DateTime(timezone=True), nullable=True))\n    status: str = Field(default=\"active\", sa_column=Column(String(length=20), nullable=False, server_default=\"active\"))  # active/inactive\n    created_at: datetime = Field(default_factory=datetime.utcnow, sa_column=Column(DateTime(timezone=True), nullable=False, server_default=func.now()))\n\n\nclass Employee(SQLModel, table=True):\n    __tablename__ = \"employees\"\n    __table_args__ = (\n        UniqueConstraint(\"employee_number\", name=\"uq_employees_employee_number\"),\n        Index(\"ix_employees_status\", \"status\"),\n    )\n\n    id: Optional[int] = Field(default=None, primary_key=True)\n    employee_number: str = Field(sa_column=Column(String(length=50), nullable=False, unique=True))\n    first_name: str = Field(sa_column=Column(String(length=120), nullable=False))\n    last_name: str = Field(sa_column=Column(String(length=120), nullable=False))\n    department_id: Optional[int] = Field(default=None, sa_column=Column(Integer, nullable=True))\n    position_id: Optional[int] = Field(default=None, sa_column=Column(Integer, nullable=True))\n    base_salary: Optional[float] = Field(default=0.0, sa_column=Column(Float, nullable=False, default=0.0))\n    pay_frequency: Optional[str] = Field(default=\"monthly\", sa_column=Column(String(length=30), nullable=False, server_default=\"monthly\"))\n    status: str = Field(default=\"active\", sa_column=Column(String(length=20), nullable=False, server_default=\"active\"))  # active/inactive\n    hire_date: Optional[date] = Field(default=None, sa_column=Column(Date, nullable=True))\n    termination_date: Optional[date] = Field(default=None, sa_column=Column(Date, nullable=True))\n    created_at: datetime = Field(default_factory=datetime.utcnow, sa_column=Column(DateTime(timezone=True), nullable=False, server_default=func.now()))\n    updated_at: datetime = Field(default_factory=datetime.utcnow, sa_column=Column(DateTime(timezone=True), nullable=False, server_default=func.now(), onupdate=func.now()))\n    deleted_at: Optional[datetime] = Field(default=None, sa_column=Column(DateTime(timezone=True), nullable=True))\n\n    # relationships (optional)\n    bank_accounts: List[\"BankAccount\"] = Relationship(back_populates=\"employee\")\n    payslips: List[\"Payslip\"] = Relationship(back_populates=\"employee\")\n    user: Optional[User] = Relationship(back_populates=\"employee\")  # reverse relation; note: User has employee_id FK\n\n\n# link back User.employee relationship attribute (deferred assignment)\nUser.employee = Relationship(back_populates=\"user\", sa_relationship_kwargs={\"uselist\": False})\n\n\nclass PayRun(SQLModel, table=True):\n    __tablename__ = \"payruns\"\n    __table_args__ = (\n        Index(\"ix_payruns_status\", \"status\"),\n    )\n\n    id: Optional[int] = Field(default=None, primary_key=True)\n    period_start: date = Field(sa_column=Column(Date, nullable=False))\n    period_end: date = Field(sa_column=Column(Date, nullable=False))\n    created_by: Optional[int] = Field(default=None, foreign_key=\"users.id\", sa_column=Column(Integer, ForeignKey(\"users.id\"), nullable=True))\n    status: str = Field(default=\"DRAFT\", sa_column=Column(String(length=30), nullable=False, server_default=\"DRAFT\"))  # DRAFT/PENDING/APPROVED/ISSUED\n    total_gross: float = Field(default=0.0, sa_column=Column(Float, nullable=False, default=0.0))\n    total_net: float = Field(default=0.0, sa_column=Column(Float, nullable=False, default=0.0))\n    created_at: datetime = Field(default_factory=datetime.utcnow, sa_column=Column(DateTime(timezone=True), nullable=False, server_default=func.now()))\n    approved_at: Optional[datetime] = Field(default=None, sa_column=Column(DateTime(timezone=True), nullable=True))\n    issued_at: Optional[datetime] = Field(default=None, sa_column=Column(DateTime(timezone=True), nullable=True))\n    version: int = Field(default=1, sa_column=Column(Integer, nullable=False, default=1))\n\n\nclass Payslip(SQLModel, table=True):\n    __tablename__ = \"payslips\"\n    __table_args__ = (\n        UniqueConstraint(\"payslip_number\", name=\"uq_payslips_payslip_number\"),\n        Index(\"ix_payslips_status\", \"status\"),\n    )\n\n    id: Optional[int] = Field(default=None, primary_key=True)\n    payslip_number: str = Field(sa_column=Column(String(length=100), nullable=False, unique=True))\n    payrun_id: int = Field(foreign_key=\"payruns.id\", sa_column=Column(Integer, ForeignKey(\"payruns.id\"), nullable=False))\n    employee_id: int = Field(foreign_key=\"employees.id\", sa_column=Column(Integer, ForeignKey(\"employees.id\"), nullable=False))\n    gross_pay: float = Field(default=0.0, sa_column=Column(Float, nullable=False, default=0.0))\n    tax_amount: float = Field(default=0.0, sa_column=Column(Float, nullable=False, default=0.0))\n    other_deductions: float = Field(default=0.0, sa_column=Column(Float, nullable=False, default=0.0))\n    benefits: float = Field(default=0.0, sa_column=Column(Float, nullable=False, default=0.0))\n    net_pay: float = Field(default=0.0, sa_column=Column(Float, nullable=False, default=0.0))\n    status: str = Field(default=\"PENDING\", sa_column=Column(String(length=30), nullable=False, server_default=\"PENDING\"))  # PENDING/APPROVED/ISSUED\n    issued_date: Optional[datetime] = Field(default=None, sa_column=Column(DateTime(timezone=True), nullable=True))\n    created_at: datetime = Field(default_factory=datetime.utcnow, sa_column=Column(DateTime(timezone=True), nullable=False, server_default=func.now()))\n    version: int = Field(default=1, sa_column=Column(Integer, nullable=False, default=1))\n\n    # relationships\n    employee: Optional[Employee] = Relationship(back_populates=\"payslips\")\n    payrun: Optional[PayRun] = Relationship()\n\n\nclass BankAccount(SQLModel, table=True):\n    __tablename__ = \"bank_accounts\"\n    __table_args__ = (\n        Index(\"ix_bank_accounts_employee_primary\", \"employee_id\", \"is_primary\"),\n    )\n\n    id: Optional[int] = Field(default=None, primary_key=True)\n    employee_id: int = Field(foreign_key=\"employees.id\", sa_column=Column(Integer, ForeignKey(\"employees.id\"), nullable=False))\n    bank_name: Optional[str] = Field(default=None, sa_column=Column(String(length=200), nullable=True))\n    account_number_masked: Optional[str] = Field(default=None, sa_column=Column(String(length=64), nullable=True))\n    encrypted_account_blob: Optional[bytes] = Field(default=None, sa_column=Column(LargeBinary, nullable=True))\n    iban: Optional[str] = Field(default=None, sa_column=Column(String(length=64), nullable=True))\n    account_type: Optional[str] = Field(default=None, sa_column=Column(String(length=50), nullable=True))\n    is_primary: bool = Field(default=False, sa_column=Column(Boolean, nullable=False, default=False))\n    created_at: datetime = Field(default_factory=datetime.utcnow, sa_column=Column(DateTime(timezone=True), nullable=False, server_default=func.now()))\n\n    # relationships\n    employee: Optional[Employee] = Relationship(back_populates=\"bank_accounts\")\n\n\nclass TaxRule(SQLModel, table=True):\n    __tablename__ = \"tax_rules\"\n    __table_args__ = (\n        Index(\"ix_tax_rules_effective_range\", \"effective_from\", \"effective_to\"),\n    )\n\n    id: Optional[int] = Field(default=None, primary_key=True)\n    name: str = Field(sa_column=Column(String(length=200), nullable=False))\n    effective_from: date = Field(sa_column=Column(Date, nullable=False))\n    effective_to: Optional[date] = Field(default=None, sa_column=Column(Date, nullable=True))\n    rule_definition: Optional[Dict[str, Any]] = Field(default=None, sa_column=Column(JSON, nullable=True))\n    created_at: datetime = Field(default_factory=datetime.utcnow, sa_column=Column(DateTime(timezone=True), nullable=False, server_default=func.now()))\n\n\nclass AuditLog(SQLModel, table=True):\n    __tablename__ = \"audit_logs\"\n    __table_args__ = (\n        Index(\"ix_audit_logs_actor\", \"actor_user_id\"),\n        Index(\"ix_audit_logs_entity\", \"entity_type\", \"entity_id\"),\n    )\n\n    id: Optional[int] = Field(default=None, primary_key=True)\n    actor_user_id: Optional[int] = Field(default=None, foreign_key=\"users.id\", sa_column=Column(Integer, ForeignKey(\"users.id\"), nullable=True))\n    action: str = Field(sa_column=Column(String(length=100), nullable=False))  # create/update/delete/approve/issue/export\n    entity_type: Optional[str] = Field(default=None, sa_column=Column(String(length=100), nullable=True))\n    entity_id: Optional[int] = Field(default=None, sa_column=Column(Integer, nullable=True))\n    timestamp: datetime = Field(default_factory=datetime.utcnow, sa_column=Column(DateTime(timezone=True), nullable=False, server_default=func.now()))\n    details: Optional[Dict[str, Any]] = Field(default=None, sa_column=Column(JSON, nullable=True))"}, {"path": "app/schemas.py", "content": "from datetime import date, datetime\nfrom decimal import Decimal, InvalidOperation, ROUND_HALF_UP\nfrom enum import Enum\nfrom typing import Dict, List, Optional\n\nfrom pydantic import Field, root_validator, validator, condecimal, constr\nfrom sqlmodel import SQLModel\n\n\n# Utility decimal type: non-negative monetary amount with two decimal places\nMoney = condecimal(gt=-1, max_digits=18, decimal_places=2)\n\n\nclass Role(str, Enum):\n    payroll_admin = \"payroll-admin\"\n    approver = \"approver\"\n    hr = \"hr\"\n    employee = \"employee\"\n    auditor = \"auditor\"\n\n\nclass Status(str, Enum):\n    active = \"active\"\n    inactive = \"inactive\"\n    pending = \"pending\"\n    draft = \"draft\"\n    approved = \"approved\"\n    issued = \"issued\"\n\n\n# ===== Auth Schemas =====\nclass LoginRequest(SQLModel):\n    username: constr(strip_whitespace=True, min_length=1) = Field(...)\n    password: constr(min_length=6) = Field(...)\n\n\nclass Token(SQLModel):\n    access_token: str = Field(...)\n    token_type: str = Field(default=\"bearer\")\n\n\nclass TokenPayload(SQLModel):\n    sub: Optional[str] = None\n    user_id: Optional[int] = None\n    roles: Optional[List[Role]] = None\n    exp: Optional[int] = None\n\n\n# ===== User Schemas =====\nclass UserCreate(SQLModel):\n    username: constr(strip_whitespace=True, min_length=1) = Field(...)\n    password: constr(min_length=6) = Field(...)\n    role: Role = Field(default=Role.employee)\n    employee_id: Optional[int] = None\n\n\nclass UserRead(SQLModel):\n    id: int\n    username: str\n    role: Role\n    employee_id: Optional[int] = None\n    status: Status = Field(default=Status.active)\n    created_at: Optional[datetime] = None\n\n\nclass UserUpdate(SQLModel):\n    password: Optional[constr(min_length=6)] = None\n    role: Optional[Role] = None\n    employee_id: Optional[int] = None\n    status: Optional[Status] = None\n\n\n# ===== Employee Schemas =====\nclass EmployeeBase(SQLModel):\n    employee_number: constr(strip_whitespace=True, min_length=1)\n    first_name: constr(strip_whitespace=True, min_length=1)\n    last_name: constr(strip_whitespace=True, min_length=1)\n    department_id: Optional[int] = None\n    position_id: Optional[int] = None\n    base_salary: Optional[Money] = Field(default=Decimal(\"0.00\"))\n    pay_frequency: Optional[constr(strip_whitespace=True)] = Field(default=\"monthly\")\n    status: Status = Field(default=Status.active)\n    hire_date: Optional[date] = None\n    termination_date: Optional[date] = None\n\n\nclass EmployeeCreate(EmployeeBase):\n    pass\n\n\nclass EmployeeRead(EmployeeBase):\n    id: int\n    created_at: Optional[datetime] = None\n    updated_at: Optional[datetime] = None\n\n\nclass EmployeeUpdate(SQLModel):\n    employee_number: Optional[constr(strip_whitespace=True, min_length=1)] = None\n    first_name: Optional[constr(strip_whitespace=True, min_length=1)] = None\n    last_name: Optional[constr(strip_whitespace=True, min_length=1)] = None\n    department_id: Optional[int] = None\n    position_id: Optional[int] = None\n    base_salary: Optional[Money] = None\n    pay_frequency: Optional[constr(strip_whitespace=True)] = None\n    status: Optional[Status] = None\n    hire_date: Optional[date] = None\n    termination_date: Optional[date] = None\n\n\n# ===== Bank Account Schemas =====\nclass BankAccountCreate(SQLModel):\n    bank_name: constr(strip_whitespace=True, min_length=1)\n    account_number: constr(strip_whitespace=True, min_length=4)\n    iban: Optional[constr(strip_whitespace=True)] = None\n    account_type: Optional[constr(strip_whitespace=True)] = Field(default=\"checking\")\n    is_primary: bool = Field(default=False)\n\n\nclass BankAccountRead(SQLModel):\n    id: int\n    bank_name: str\n    account_number_masked: str\n    iban: Optional[str] = None\n    account_type: str\n    is_primary: bool = False\n    created_at: Optional[datetime] = None\n\n\n# ===== Tax Rule Schemas =====\nclass TaxRuleCreate(SQLModel):\n    name: constr(strip_whitespace=True, min_length=1)\n    effective_from: date\n    effective_to: Optional[date] = None\n    rule_definition: Dict = Field(default_factory=dict)\n\n\nclass TaxRuleRead(TaxRuleCreate):\n    id: int\n    created_at: Optional[datetime] = None\n\n\n# ===== PayRun Schemas =====\nclass PayRunCreate(SQLModel):\n    period_start: date = Field(...)\n    period_end: date = Field(...)\n\n    @validator(\"period_end\")\n    def end_must_be_after_start(cls, v, values):\n        start = values.get(\"period_start\")\n        if start and v < start:\n            raise ValueError(\"period_end must be on or after period_start\")\n        return v\n\n\nclass PayRunRead(SQLModel):\n    id: int\n    period_start: date\n    period_end: date\n    created_by: Optional[int] = None\n    status: Status = Field(default=Status.pending)\n    total_gross: Decimal = Field(default=Decimal(\"0.00\"))\n    total_net: Decimal = Field(default=Decimal(\"0.00\"))\n    created_at: Optional[datetime] = None\n    approved_at: Optional[datetime] = None\n    issued_at: Optional[datetime] = None\n    version: int = Field(default=1)\n\n\nclass PayRunAction(SQLModel):\n    expected_version: int = Field(..., ge=1)\n\n\n# ===== Payslip Schemas =====\nclass PayslipBase(SQLModel):\n    gross_pay: Money = Field(default=Decimal(\"0.00\"))\n    tax_amount: Money = Field(default=Decimal(\"0.00\"))\n    other_deductions: Money = Field(default=Decimal(\"0.00\"))\n    benefits: Optional[Money] = Field(default=Decimal(\"0.00\"))\n\n\nclass PayslipCreate(PayslipBase):\n    payrun_id: int\n    employee_id: int\n\n    @root_validator\n    def compute_net_if_missing(cls, values):\n        gross = values.get(\"gross_pay\", Decimal(\"0.00\"))\n        tax = values.get(\"tax_amount\", Decimal(\"0.00\"))\n        other = values.get(\"other_deductions\", Decimal(\"0.00\"))\n        try:\n            net = (Decimal(gross) - Decimal(tax) - Decimal(other)).quantize(\n                Decimal(\"0.01\"), rounding=ROUND_HALF_UP\n            )\n        except (InvalidOperation, TypeError):\n            raise ValueError(\"Invalid monetary values provided\")\n        values[\"net_pay\"] = net\n        return values\n\n\nclass PayslipRead(PayslipBase):\n    id: int\n    payslip_number: Optional[str] = None\n    payrun_id: int\n    employee_id: int\n    net_pay: Decimal\n    status: Status = Field(default=Status.pending)\n    issued_date: Optional[datetime] = None\n    created_at: Optional[datetime] = None\n    version: int = Field(default=1)\n\n    @validator(\"net_pay\")\n    def net_non_negative(cls, v):\n        if v < 0:\n            raise ValueError(\"net_pay must be non-negative\")\n        return v\n\n\nclass PayslipList(SQLModel):\n    payslips: List[PayslipRead] = Field(default_factory=list)\n\n\n# ===== Audit Schemas =====\nclass AuditEntryCreate(SQLModel):\n    actor_user_id: int = Field(...)\n    action: constr(strip_whitespace=True, min_length=1)\n    entity_type: constr(strip_whitespace=True, min_length=1)\n    entity_id: Optional[int] = None\n    details: Optional[Dict] = Field(default_factory=dict)\n\n\nclass AuditEntryRead(AuditEntryCreate):\n    id: int\n    timestamp: datetime\n\n\n# ===== Export Record Schema (minimal) =====\nclass ExportRecordCreate(SQLModel):\n    payrun_id: int\n    created_by: int\n    checksum: Optional[str] = None\n    path_or_uri: Optional[str] = None\n\n\nclass ExportRecordRead(ExportRecordCreate):\n    id: int\n    created_at: Optional[datetime] = None\n    status: Optional[Status] = None\n\n\n# ===== Generic Response Models =====\nclass Message(SQLModel):\n    detail: str\n\n\n# Allow ORM mode for SQLModel <-> Pydantic integration\nfor cls in (\n    LoginRequest,\n    Token,\n    TokenPayload,\n    UserCreate,\n    UserRead,\n    UserUpdate,\n    EmployeeCreate,\n    EmployeeRead,\n    EmployeeUpdate,\n    BankAccountCreate,\n    BankAccountRead,\n    TaxRuleCreate,\n    TaxRuleRead,\n    PayRunCreate,\n    PayRunRead,\n    PayRunAction,\n    PayslipCreate,\n    PayslipRead,\n    PayslipList,\n    AuditEntryCreate,\n    AuditEntryRead,\n    ExportRecordCreate,\n    ExportRecordRead,\n    Message,\n):\n    cls.model_config = getattr(cls, \"model_config\", {})\n    # SQLModel already sets orm_mode, but ensure it's present for pydantic v2 compat\n    cls.model_config[\"orm_mode\"] = True\n    cls.model_config[\"from_attributes\"] = True  # helpful for object conversion when used with SQLModel instances"}, {"path": "app/routes.py", "content": "from typing import Optional, List\nfrom datetime import datetime, date\nimport json\n\nfrom fastapi import APIRouter, Depends, HTTPException, status, Body\nfrom pydantic import BaseModel, Field, validator, constr\nfrom sqlmodel import select\n\nfrom app.database import get_session\nfrom app.models import User, Employee, PayRun, Payslip, BankAccount, AuditLog\nfrom app.auth import (\n    authenticate_user,\n    create_access_token,\n    get_current_user,\n    require_roles,\n    hash_password,\n)\n\nrouter = APIRouter()\n\n\n# Pydantic request models for validation\nclass CreateUserRequest(BaseModel):\n    username: constr(min_length=1)\n    password: constr(min_length=8)\n    role: Optional[str] = \"employee\"\n    employee_id: Optional[int] = None\n\n    @validator(\"role\")\n    def validate_role(cls, v):\n        allowed = {\"payroll-admin\", \"approver\", \"hr\", \"employee\", \"auditor\"}\n        if v not in allowed:\n            raise ValueError(f\"role must be one of {sorted(list(allowed))}\")\n        return v\n\n\nclass UpdateUserRequest(BaseModel):\n    role: Optional[str] = None\n    employee_id: Optional[int] = None\n    password: Optional[constr(min_length=8)] = None\n\n    @validator(\"role\")\n    def validate_role(cls, v):\n        if v is None:\n            return v\n        allowed = {\"payroll-admin\", \"approver\", \"hr\", \"employee\", \"auditor\"}\n        if v not in allowed:\n            raise ValueError(f\"role must be one of {sorted(list(allowed))}\")\n        return v\n\n\nclass CreateEmployeeRequest(BaseModel):\n    employee_number: constr(min_length=1)\n    name: constr(min_length=1)\n    base_salary: float = Field(..., ge=0)\n    pay_frequency: constr(min_length=1)\n    department_id: Optional[int] = None\n    position_id: Optional[int] = None\n    status: Optional[str] = \"active\"\n    hire_date: Optional[date] = None\n\n    @validator(\"pay_frequency\")\n    def validate_pay_frequency(cls, v):\n        allowed = {\"monthly\", \"weekly\", \"biweekly\", \"annually\"}\n        if v not in allowed:\n            raise ValueError(f\"pay_frequency must be one of {sorted(list(allowed))}\")\n        return v\n\n    @validator(\"status\")\n    def validate_status(cls, v):\n        allowed_status = {\"active\", \"inactive\"}\n        if v not in allowed_status:\n            raise ValueError(f\"status must be one of {sorted(list(allowed_status))}\")\n        return v\n\n\nclass UpdateEmployeeRequest(BaseModel):\n    name: Optional[constr(min_length=1)] = None\n    department_id: Optional[int] = None\n    position_id: Optional[int] = None\n    base_salary: Optional[float] = Field(None, ge=0)\n    pay_frequency: Optional[constr(min_length=1)] = None\n    status: Optional[str] = None\n    termination_date: Optional[date] = None\n\n    @validator(\"pay_frequency\")\n    def validate_pay_frequency(cls, v):\n        if v is None:\n            return v\n        allowed = {\"monthly\", \"weekly\", \"biweekly\", \"annually\"}\n        if v not in allowed:\n            raise ValueError(f\"pay_frequency must be one of {sorted(list(allowed))}\")\n        return v\n\n    @validator(\"status\")\n    def validate_status(cls, v):\n        if v is None:\n            return v\n        allowed_status = {\"active\", \"inactive\"}\n        if v not in allowed_status:\n            raise ValueError(f\"status must be one of {sorted(list(allowed_status))}\")\n        return v\n\n\n# -----------------------\n# Auth endpoints\n# -----------------------\n@router.post(\"/auth/login\")\ndef login(\n    credentials: dict = Body(...),\n    session=Depends(get_session),\n):\n    \"\"\"\n    Expect body: {\"username\": \"...\", \"password\": \"...\"}\n    Returns: {\"access_token\": \"...\", \"token_type\":\"bearer\"}\n    \"\"\"\n    username = credentials.get(\"username\")\n    password = credentials.get(\"password\")\n    if not username or not password:\n        raise HTTPException(status_code=400, detail=\"username and password required\")\n\n    user = authenticate_user(session, username, password)\n    if not user:\n        raise HTTPException(status_code=401, detail=\"Invalid credentials\")\n\n    token_data = {\"sub\": str(user.id), \"roles\": user.role if hasattr(user, \"role\") else None}\n    access_token = create_access_token(token_data)\n    # update last_login\n    try:\n        user.last_login = datetime.utcnow()\n        session.add(user)\n        session.commit()\n    except Exception:\n        session.rollback()\n\n    return {\"access_token\": access_token, \"token_type\": \"bearer\"}\n\n\n@router.post(\"/auth/logout\")\ndef logout(current_user: User = Depends(get_current_user)):\n    # Minimal logout endpoint. Token revocation implemented in auth layer if available.\n    return {\"msg\": \"logged out\"}\n\n\n@router.get(\"/auth/me\")\ndef me(current_user: User = Depends(get_current_user)):\n    return {\n        \"id\": getattr(current_user, \"id\", None),\n        \"username\": getattr(current_user, \"username\", None),\n        \"role\": getattr(current_user, \"role\", None),\n        \"employee_id\": getattr(current_user, \"employee_id\", None),\n        \"status\": getattr(current_user, \"status\", None),\n    }\n\n\n# -----------------------\n# User endpoints\n# -----------------------\n@router.post(\"/users\", status_code=201)\ndef create_user(\n    payload: CreateUserRequest = Body(...),\n    session=Depends(get_session),\n    current_user: User = Depends(require_roles([\"payroll-admin\"])),\n):\n    username = payload.username\n    password = payload.password\n    role = payload.role\n    employee_id = payload.employee_id\n\n    # ensure username uniqueness\n    existing = session.exec(select(User).where(User.username == username)).first()\n    if existing:\n        raise HTTPException(status_code=409, detail=\"username already exists\")\n\n    user = User(\n        username=username,\n        password_hash=hash_password(password),\n        role=role,\n        employee_id=employee_id,\n        status=\"active\",\n        created_at=datetime.utcnow(),\n    )\n    try:\n        session.add(user)\n        session.commit()\n        session.refresh(user)\n    except Exception as e:\n        session.rollback()\n        raise HTTPException(status_code=500, detail=\"Failed to create user\")\n\n    # audit\n    try:\n        audit = AuditLog(\n            actor_user_id=current_user.id,\n            action=\"create\",\n            entity_type=\"user\",\n            entity_id=user.id,\n            timestamp=datetime.utcnow(),\n            details=json.dumps({\"username\": username, \"role\": role}),\n        )\n        session.add(audit)\n        session.commit()\n    except Exception:\n        session.rollback()\n\n    return {\"id\": user.id, \"username\": user.username, \"role\": user.role, \"employee_id\": user.employee_id}\n\n\n@router.get(\"/users\", dependencies=[Depends(require_roles([\"payroll-admin\"]))])\ndef list_users(session=Depends(get_session)):\n    users = session.exec(select(User)).all()\n    result = []\n    for u in users:\n        result.append({\"id\": u.id, \"username\": u.username, \"role\": getattr(u, \"role\", None), \"status\": getattr(u, \"status\", None)})\n    return result\n\n\n@router.get(\"/users/{user_id}\")\ndef get_user(user_id: int, session=Depends(get_session), current_user: User = Depends(get_current_user)):\n    user = session.get(User, user_id)\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n\n    # allow admins or self\n    if current_user.id != user.id and getattr(current_user, \"role\", \"\") != \"payroll-admin\":\n        raise HTTPException(status_code=403, detail=\"Not authorized\")\n\n    return {\"id\": user.id, \"username\": user.username, \"role\": getattr(user, \"role\", None), \"employee_id\": getattr(user, \"employee_id\", None)}\n\n\n@router.put(\"/users/{user_id}\")\ndef update_user(\n    user_id: int,\n    payload: UpdateUserRequest = Body(...),\n    session=Depends(get_session),\n    current_user: User = Depends(require_roles([\"payroll-admin\"])),\n):\n    user = session.get(User, user_id)\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n\n    updated_fields = []\n    if payload.role is not None:\n        user.role = payload.role\n        updated_fields.append(\"role\")\n    if payload.employee_id is not None:\n        user.employee_id = payload.employee_id\n        updated_fields.append(\"employee_id\")\n    if payload.password is not None:\n        try:\n            user.password_hash = hash_password(payload.password)\n            updated_fields.append(\"password\")\n        except Exception:\n            raise HTTPException(status_code=500, detail=\"Failed to update password\")\n\n    user.updated_at = datetime.utcnow()\n    try:\n        session.add(user)\n        session.commit()\n        session.refresh(user)\n    except Exception:\n        session.rollback()\n        raise HTTPException(status_code=500, detail=\"Failed to update user\")\n\n    try:\n        audit = AuditLog(\n            actor_user_id=current_user.id,\n            action=\"update\",\n            entity_type=\"user\",\n            entity_id=user.id,\n            timestamp=datetime.utcnow(),\n            details=json.dumps({\"updated_fields\": updated_fields}),\n        )\n        session.add(audit)\n        session.commit()\n    except Exception:\n        session.rollback()\n\n    return {\"id\": user.id, \"username\": user.username, \"role\": getattr(user, \"role\", None)}\n\n\n@router.delete(\"/users/{user_id}\", status_code=204)\ndef delete_user(user_id: int, session=Depends(get_session), current_user: User = Depends(require_roles([\"payroll-admin\"]))):\n    user = session.get(User, user_id)\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n\n    user.status = \"inactive\"\n    user.updated_at = datetime.utcnow()\n    try:\n        session.add(user)\n        session.commit()\n    except Exception:\n        session.rollback()\n        raise HTTPException(status_code=500, detail=\"Failed to deactivate user\")\n\n    try:\n        audit = AuditLog(\n            actor_user_id=current_user.id,\n            action=\"delete\",\n            entity_type=\"user\",\n            entity_id=user.id,\n            timestamp=datetime.utcnow(),\n            details=json.dumps({\"soft_deleted\": True}),\n        )\n        session.add(audit)\n        session.commit()\n    except Exception:\n        session.rollback()\n    return {}\n\n\n# -----------------------\n# Employee endpoints\n# -----------------------\n@router.post(\"/employees\", status_code=201)\ndef create_employee(\n    payload: CreateEmployeeRequest = Body(...),\n    session=Depends(get_session),\n    current_user: User = Depends(require_roles([\"hr\", \"payroll-admin\"])),\n):\n    # payload is validated by Pydantic\n    existing = session.exec(select(Employee).where(Employee.employee_number == payload.employee_number)).first()\n    if existing:\n        raise HTTPException(status_code=409, detail=\"employee_number already exists\")\n\n    emp = Employee(\n        employee_number=payload.employee_number,\n        name=payload.name,\n        department_id=payload.department_id,\n        position_id=payload.position_id,\n        base_salary=payload.base_salary,\n        pay_frequency=payload.pay_frequency,\n        status=payload.status,\n        hire_date=payload.hire_date,\n        created_at=datetime.utcnow(),\n    )\n    try:\n        session.add(emp)\n        session.commit()\n        session.refresh(emp)\n    except Exception:\n        session.rollback()\n        raise HTTPException(status_code=500, detail=\"Failed to create employee\")\n\n    try:\n        audit = AuditLog(\n            actor_user_id=current_user.id,\n            action=\"create\",\n            entity_type=\"employee\",\n            entity_id=emp.id,\n            timestamp=datetime.utcnow(),\n            details=json.dumps({\"employee_number\": emp.employee_number}),\n        )\n        session.add(audit)\n        session.commit()\n    except Exception:\n        session.rollback()\n\n    return {\"id\": emp.id, \"employee_number\": emp.employee_number, \"name\": emp.name}\n\n\n@router.get(\"/employees\")\ndef list_employees(status: Optional[str] = None, session=Depends(get_session), current_user: User = Depends(get_current_user)):\n    q = select(Employee)\n    if status:\n        q = q.where(Employee.status == status)\n    employees = session.exec(q).all()\n    return [\n        {\n            \"id\": e.id,\n            \"employee_number\": e.employee_number,\n            \"name\": getattr(e, \"name\", None),\n            \"status\": getattr(e, \"status\", None),\n        }\n        for e in employees\n    ]\n\n\n@router.get(\"/employees/{employee_id}\")\ndef get_employee(employee_id: int, session=Depends(get_session), current_user: User = Depends(get_current_user)):\n    emp = session.get(Employee, employee_id)\n    if not emp:\n        raise HTTPException(status_code=404, detail=\"Employee not found\")\n    return {\n        \"id\": emp.id,\n        \"employee_number\": emp.employee_number,\n        \"name\": getattr(emp, \"name\", None),\n        \"status\": getattr(emp, \"status\", None),\n        \"base_salary\": getattr(emp, \"base_salary\", None),\n    }\n\n\n@router.put(\"/employees/{employee_id}\")\ndef update_employee(\n    employee_id: int,\n    payload: UpdateEmployeeRequest = Body(...),\n    session=Depends(get_session),\n    current_user: User = Depends(require_roles([\"hr\", \"payroll-admin\"])),\n):\n    emp = session.get(Employee, employee_id)\n    if not emp:\n        raise HTTPException(status_code=404, detail=\"Employee not found\")\n\n    updated_fields = []\n    for k in [\"name\", \"department_id\", \"position_id\", \"base_salary\", \"pay_frequency\", \"status\", \"termination_date\"]:\n        if getattr(payload, k) is not None:\n            setattr(emp, k, getattr(payload, k))\n            updated_fields.append(k)\n\n    emp.updated_at = datetime.utcnow()\n    try:\n        session.add(emp)\n        session.commit()\n        session.refresh(emp)\n    except Exception:\n        session.rollback()\n        raise HTTPException(status_code=500, detail=\"Failed to update employee\")\n\n    try:\n        audit = AuditLog(\n            actor_user_id=current_user.id,\n            action=\"update\",\n            entity_type=\"employee\",\n            entity_id=emp.id,\n            timestamp=datetime.utcnow(),\n            details=json.dumps({\"updated_fields\": updated_fields}),\n        )\n        session.add(audit)\n        session.commit()\n    except Exception:\n        session.rollback()\n\n    return {\"id\": emp.id, \"employee_number\": emp.employee_number, \"name\": emp.name}\n\n\n@router.delete(\"/employees/{employee_id}\", status_code=204)\ndef delete_employee(employee_id: int, session=Depends(get_session), current_user: User = Depends(require_roles([\"hr\", \"payroll-admin\"]))):\n    emp = session.get(Employee, employee_id)\n    if not emp:\n        raise HTTPException(status_code=404, detail=\"Employee not found\")\n    emp.status = \"inactive\"\n    emp.updated_at = datetime.utcnow()\n    try:\n        session.add(emp)\n        session.commit()\n    except Exception:\n        session.rollback()\n        raise HTTPException(status_code=500, detail=\"Failed to deactivate employee\")\n\n    try:\n        audit = AuditLog(\n            actor_user_id=current_user.id,\n            action=\"delete\",\n            entity_type=\"employee\",\n            entity_id=emp.id,\n            timestamp=datetime.utcnow(),\n            details=json.dumps({\"soft_deleted\": True}),\n        )\n        session.add(audit)\n        session.commit()\n    except Exception:\n        session.rollback()\n    return {}\n\n\n# -----------------------\n# PayRun endpoints\n# -----------------------\n@router.post(\"/payruns\", status_code=201)\ndef create_payrun(payload: dict = Body(...), session=Depends(get_session), current_user: User = Depends(require_roles([\"payroll-admin\", \"hr\"]))):\n    if \"period_start\" not in payload or \"period_end\" not in payload:\n        raise HTTPException(status_code=400, detail=\"period_start and period_end required\")\n    try:\n        period_start = date.fromisoformat(payload[\"period_start\"])\n        period_end = date.fromisoformat(payload[\"period_end\"])\n    except Exception:\n        raise HTTPException(status_code=400, detail=\"invalid date format, use YYYY-MM-DD\")\n\n    payrun = PayRun(\n        period_start=period_start,\n        period_end=period_end,\n        created_by=current_user.id,\n        status=\"PENDING\",\n        total_gross=0,\n        total_net=0,\n        created_at=datetime.utcnow(),\n        version=1,\n    )\n    session.add(payrun)\n    session.commit()\n    session.refresh(payrun)\n\n    audit = AuditLog(\n        actor_user_id=current_user.id,\n        action=\"create\",\n        entity_type=\"payrun\",\n        entity_id=payrun.id,\n        timestamp=datetime.utcnow(),\n        details=json.dumps({\"period_start\": str(period_start), \"period_end\": str(period_end)}),\n    )\n    session.add(audit)\n    session.commit()\n\n    return {\"id\": payrun.id, \"status\": payrun.status}\n\n\n@router.get(\"/payruns\")\ndef list_payruns(session=Depends(get_session), current_user: User = Depends(get_current_user)):\n    q = select(PayRun)\n    runs = session.exec(q).all()\n    return [\n        {\n            \"id\": r.id,\n            \"period_start\": getattr(r, \"period_start\", None),\n            \"period_end\": getattr(r, \"period_end\", None),\n            \"status\": getattr(r, \"status\", None),\n            \"version\": getattr(r, \"version\", None),\n        }\n        for r in runs\n    ]\n\n\n@router.get(\"/payruns/{payrun_id}\")\ndef get_payrun(payrun_id: int, session=Depends(get_session), current_user: User = Depends(get_current_user)):\n    pr = session.get(PayRun, payrun_id)\n    if not pr:\n        raise HTTPException(status_code=404, detail=\"PayRun not found\")\n    return {\n        \"id\": pr.id,\n        \"period_start\": getattr(pr, \"period_start\", None),\n        \"period_end\": getattr(pr, \"period_end\", None),\n        \"status\": getattr(pr, \"status\", None),\n        \"version\": getattr(pr, \"version\", None),\n        \"total_gross\": getattr(pr, \"total_gross\", None),\n        \"total_net\": getattr(pr, \"total_net\", None),\n    }\n\n\n@router.post(\"/payruns/{payrun_id}/approve\")\ndef approve_payrun(payrun_id: int, body: dict = Body(...), session=Depends(get_session), current_user: User = Depends(require_roles([\"approver\", \"payroll-admin\"]))):\n    expected_version = body.get(\"expected_version\")\n    if expected_version is None:\n        raise HTTPException(status_code=400, detail=\"expected_version required\")\n\n    # lock payrun row\n    q = select(PayRun).where(PayRun.id == payrun_id).with_for_update()\n    pr = session.exec(q).first()\n    if not pr:\n        raise HTTPException(status_code=404, detail=\"PayRun not found\")\n\n    if pr.version != expected_version:\n        raise HTTPException(status_code=409, detail=\"version mismatch\")\n\n    if pr.status not in (\"PENDING\", \"READY\"):\n        raise HTTPException(status_code=400, detail=f\"cannot approve payrun in status {pr.status}\")\n\n    pr.status = \"APPROVED\"\n    pr.approved_at = datetime.utcnow()\n    pr.version = (pr.version or 0) + 1\n    session.add(pr)\n\n    audit = AuditLog(\n        actor_user_id=current_user.id,\n        action=\"approve\",\n        entity_type=\"payrun\",\n        entity_id=pr.id,\n        timestamp=datetime.utcnow(),\n        details=json.dumps({\"previous_version\": expected_version}),\n    )\n    session.add(audit)\n    session.commit()\n    session.refresh(pr)\n\n    return {\"id\": pr.id, \"status\": pr.status, \"version\": pr.version}\n\n\n@router.post(\"/payruns/{payrun_id}/issue\")\ndef issue_payrun(payrun_id: int, body: dict = Body(...), session=Depends(get_session), current_user: User = Depends(require_roles([\"payroll-admin\", \"approver\"]))):\n    expected_version = body.get(\"expected_version\")\n    if expected_version is None:\n        raise HTTPException(status_code=400, detail=\"expected_version required\")\n\n    # optimistic lock via where + version check is emulated by select for update then version compare\n    q = select(PayRun).where(PayRun.id == payrun_id).with_for_update()\n    pr = session.exec(q).first()\n    if not pr:\n        raise HTTPException(status_code=404, detail=\"PayRun not found\")\n\n    if pr.version != expected_version:\n        raise HTTPException(status_code=409, detail=\"version mismatch\")\n\n    if pr.status != \"APPROVED\":\n        raise HTTPException(status_code=400, detail=\"PayRun must be APPROVED before issuing\")\n\n    # ensure there are payslips\n    payslips = session.exec(select(Payslip).where(Payslip.payrun_id == pr.id)).all()\n    if not payslips:\n        raise HTTPException(status_code=400, detail=\"No payslips found for payrun\")\n\n    # ensure each employee has primary bank account\n    emp_ids = {p.employee_id for p in payslips}\n    missing_bank = []\n    for eid in emp_ids:\n        bank = session.exec(select(BankAccount).where(BankAccount.employee_id == eid, BankAccount.is_primary == True)).first()\n        if not bank:\n            missing_bank.append(eid)\n    if missing_bank:\n        raise HTTPException(status_code=400, detail=f\"Missing primary bank account for employees: {missing_bank}\")\n\n    # mark payslips as ISSUED and payrun issued\n    now = datetime.utcnow()\n    for p in payslips:\n        if getattr(p, \"status\", \"\") == \"ISSUED\":\n            continue\n        p.status = \"ISSUED\"\n        p.issued_date = now\n        p.version = (p.version or 0) + 1\n        session.add(p)\n\n    pr.status = \"ISSUED\"\n    pr.issued_at = now\n    pr.version = (pr.version or 0) + 1\n    session.add(pr)\n\n    audit = AuditLog(\n        actor_user_id=current_user.id,\n        action=\"issue\",\n        entity_type=\"payrun\",\n        entity_id=pr.id,\n        timestamp=now,\n        details=json.dumps({\"issued_payslips\": [p.id for p in payslips]}),\n    )\n    session.add(audit)\n    session.commit()\n    session.refresh(pr)\n\n    return {\"id\": pr.id, \"status\": pr.status, \"version\": pr.version}\n\n\n# -----------------------\n# Payslip endpoints\n# -----------------------\n@router.get(\"/payslips\")\ndef list_payslips(employee_id: Optional[int] = None, payrun_id: Optional[int] = None, session=Depends(get_session), current_user: User = Depends(get_current_user)):\n    q = select(Payslip)\n    if employee_id:\n        q = q.where(Payslip.employee_id == employee_id)\n    if payrun_id:\n        q = q.where(Payslip.payrun_id == payrun_id)\n    slips = session.exec(q).all()\n    return [\n        {\n            \"id\": s.id,\n            \"payslip_number\": getattr(s, \"payslip_number\", None),\n            \"employee_id\": getattr(s, \"employee_id\", None),\n            \"payrun_id\": getattr(s, \"payrun_id\", None),\n            \"gross_pay\": getattr(s, \"gross_pay\", None),\n            \"net_pay\": getattr(s, \"net_pay\", None),\n            \"status\": getattr(s, \"status\", None),\n        }\n        for s in slips\n    ]\n\n\n@router.get(\"/payslips/{payslip_id}\")\ndef get_payslip(payslip_id: int, session=Depends(get_session), current_user: User = Depends(get_current_user)):\n    p = session.get(Payslip, payslip_id)\n    if not p:\n        raise HTTPException(status_code=404, detail=\"Payslip not found\")\n    return {\n        \"id\": p.id,\n        \"payslip_number\": getattr(p, \"payslip_number\", None),\n        \"employee_id\": getattr(p, \"employee_id\", None),\n        \"payrun_id\": getattr(p, \"payrun_id\", None),\n        \"gross_pay\": getattr(p, \"gross_pay\", None),\n        \"net_pay\": getattr(p, \"net_pay\", None),\n        \"status\": getattr(p, \"status\", None),\n    }\n\n\n@router.post(\"/payslips/{payslip_id}/download\")\ndef download_payslip(payslip_id: int, session=Depends(get_session), current_user: User = Depends(get_current_user)):\n    p = session.get(Payslip, payslip_id)\n    if not p:\n        raise HTTPException(status_code=404, detail=\"Payslip not found\")\n\n    # permission: owner or admin/approver/payroll-admin\n    allowed_roles = {\"payroll-admin\", \"approver\"}\n    is_owner = getattr(current_user, \"employee_id\", None) == p.employee_id\n    if not is_owner and getattr(current_user, \"role\", None) not in allowed_roles:\n        raise HTTPException(status_code=403, detail=\"Not authorized to download this payslip\")\n\n    # Normally generate PDF and return signed URL; here return a placeholder download URL and audit\n    download_url = f\"/downloads/payslip-{payslip_id}.pdf\"\n\n    audit = AuditLog(\n        actor_user_id=current_user.id,\n        action=\"download\",\n        entity_type=\"payslip\",\n        entity_id=p.id,\n        timestamp=datetime.utcnow(),\n        details=json.dumps({\"download_url\": download_url}),\n    )\n    session.add(audit)\n    session.commit()\n\n    return {\"download_url\": download_url}\n\n\n# -----------------------\n# Audit log endpoints\n# -----------------------\n@router.get(\"/audit-logs\")\ndef get_audit_logs(\n    actor_user_id: Optional[int] = None,\n    entity_type: Optional[str] = None,\n    start_date: Optional[str] = None,\n    end_date: Optional[str] = None,\n    session=Depends(get_session),\n    current_user: User = Depends(require_roles([\"auditor\", \"payroll-admin\"])),\n):\n    q = select(AuditLog)\n    if actor_user_id:\n        q = q.where(AuditLog.actor_user_id == actor_user_id)\n    if entity_type:\n        q = q.where(AuditLog.entity_type == entity_type)\n    if start_date:\n        try:\n            sd = datetime.fromisoformat(start_date)\n            q = q.where(AuditLog.timestamp >= sd)\n        except Exception:\n            raise HTTPException(status_code=400, detail=\"invalid start_date\")\n    if end_date:\n        try:\n            ed = datetime.fromisoformat(end_date)\n            q = q.where(AuditLog.timestamp <= ed)\n        except Exception:\n            raise HTTPException(status_code=400, detail=\"invalid end_date\")\n\n    logs = session.exec(q.order_by(AuditLog.timestamp.desc())).all()\n    result = []\n    for l in logs:\n        details = l.details\n        try:\n            details = json.loads(l.details) if l.details else None\n        except Exception:\n            details = l.details\n        result.append(\n            {\n                \"id\": l.id,\n                \"actor_user_id\": l.actor_user_id,\n                \"action\": l.action,\n                \"entity_type\": l.entity_type,\n                \"entity_id\": l.entity_id,\n                \"timestamp\": l.timestamp,\n                \"details\": details,\n            }\n        )\n    return result"}, {"path": "app/auth.py", "content": "from datetime import datetime, timedelta\nimport os\nfrom typing import Optional, List, Callable\n\nfrom fastapi import Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer\nfrom jose import JWTError, jwt\nfrom passlib.context import CryptContext\nfrom sqlmodel import Session, select\n\nfrom app.database import get_session\nfrom app.models import User\n\n# Configuration\nSECRET_KEY = os.getenv(\"SECRET_KEY\")\nif not SECRET_KEY:\n    raise RuntimeError(\"SECRET_KEY environment variable must be set for JWT signing\")\n\nALGORITHM = os.getenv(\"JWT_ALGORITHM\", \"HS256\")\nACCESS_TOKEN_EXPIRE_MINUTES = int(os.getenv(\"ACCESS_TOKEN_EXPIRE_MINUTES\", \"60\"))\n\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"/auth/login\")\n\n\ndef verify_password(plain_password: str, hashed_password: str) -> bool:\n    return pwd_context.verify(plain_password, hashed_password)\n\n\ndef get_password_hash(password: str) -> str:\n    return pwd_context.hash(password)\n\n\ndef create_access_token(subject: str, roles: Optional[List[str]] = None, expires_delta: Optional[timedelta] = None) -> str:\n    to_encode = {\"sub\": str(subject)}\n    if roles is not None:\n        to_encode[\"roles\"] = roles\n    expire = datetime.utcnow() + (expires_delta or timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES))\n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\n    return encoded_jwt\n\n\ndef authenticate_user(db_session: Session, username: str, password: str) -> Optional[User]:\n    statement = select(User).where(User.username == username)\n    user = db_session.exec(statement).first()\n    if not user:\n        return None\n    if not hasattr(user, \"password_hash\") or not user.password_hash:\n        return None\n    if not verify_password(password, user.password_hash):\n        return None\n    # Optional: check status field exists and is active\n    status_val = getattr(user, \"status\", None)\n    if status_val is not None and str(status_val).lower() not in (\"active\", \"enabled\", \"1\", \"true\"):\n        return None\n    return user\n\n\nasync def get_current_user(token: str = Depends(oauth2_scheme), db: Session = Depends(get_session)) -> User:\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail=\"Could not validate credentials\",\n        headers={\"WWW-Authenticate\": \"Bearer\"},\n    )\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        sub = payload.get(\"sub\")\n        if sub is None:\n            raise credentials_exception\n    except JWTError:\n        raise credentials_exception\n\n    try:\n        user_id = int(sub)\n    except (TypeError, ValueError):\n        raise credentials_exception\n\n    user = db.get(User, user_id)\n    if user is None:\n        raise credentials_exception\n\n    # Check for soft-deactivated users\n    status_val = getattr(user, \"status\", None)\n    if status_val is not None and str(status_val).lower() not in (\"active\", \"enabled\", \"1\", \"true\"):\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"User is deactivated\")\n\n    return user\n\n\ndef require_roles(required_roles: List[str]) -> Callable:\n    \"\"\"\n    Dependency generator to require at least one of the specified roles.\n    Example usage in a route:\n        @router.post(\"/approve\")\n        def approve(..., user: User = Depends(require_roles([\"approver\"]))):\n            ...\n    \"\"\"\n\n    def _dependency(current_user: User = Depends(get_current_user)) -> User:\n        user_roles = []\n        # Support single role string or list stored on user\n        role_attr = getattr(current_user, \"role\", None)\n        roles_attr = getattr(current_user, \"roles\", None)\n\n        if roles_attr:\n            if isinstance(roles_attr, (list, tuple)):\n                user_roles = [str(r) for r in roles_attr]\n            else:\n                # if stored as comma-separated string\n                if isinstance(roles_attr, str) and \",\" in roles_attr:\n                    user_roles = [r.strip() for r in roles_attr.split(\",\") if r.strip()]\n                else:\n                    user_roles = [str(roles_attr)]\n        elif role_attr:\n            user_roles = [str(role_attr)]\n        else:\n            user_roles = []\n\n        # Normalize\n        user_roles = [r.lower() for r in user_roles]\n\n        required_lower = [r.lower() for r in required_roles]\n\n        # Payroll-admin should be allowed to bypass checks in many cases\n        if \"payroll-admin\" in user_roles:\n            return current_user\n\n        for rr in required_lower:\n            if rr in user_roles:\n                return current_user\n\n        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail=\"Insufficient role privileges\")\n\n    return _dependency"}], "dependencies": ["fastapi", "sqlmodel", "uvicorn", "python-jose[cryptography]", "passlib[bcrypt]"]}