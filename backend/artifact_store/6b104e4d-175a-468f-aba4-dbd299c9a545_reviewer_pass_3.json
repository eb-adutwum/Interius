{"files": [{"path": "app/main.py", "content": "import logging\nimport time\nimport uuid\n\nfrom fastapi import FastAPI, Request\nfrom starlette.middleware.base import BaseHTTPMiddleware\nfrom starlette.types import ASGIApp, Receive, Scope, Send\n\nfrom sqlmodel import SQLModel\n\nfrom app.routes import router as todos_router\nfrom app.database import engine\n\n# Basic structured logging setup\nlogger = logging.getLogger(\"todo_api\")\nhandler = logging.StreamHandler()\nformatter = logging.Formatter(\n    '{\"time\": \"%(asctime)s\", \"level\": \"%(levelname)s\", \"name\": \"%(name)s\", \"message\": %(message)s}'\n)\nhandler.setFormatter(formatter)\nlogger.addHandler(handler)\nlogger.setLevel(logging.INFO)\n\n\nclass RequestIDMiddleware(BaseHTTPMiddleware):\n    \"\"\"\n    Middleware to attach a request id to each request and log basic request/response info.\n    \"\"\"\n\n    async def dispatch(self, request: Request, call_next):\n        request_id = str(uuid.uuid4())\n        request.state.request_id = request_id\n\n        start_time = time.time()\n        response = await call_next(request)\n        process_time = time.time() - start_time\n\n        # Add request id header to the response\n        response.headers[\"X-Request-ID\"] = request_id\n\n        # Log structured info\n        log_data = {\n            \"request_id\": request_id,\n            \"method\": request.method,\n            \"path\": request.url.path,\n            \"status_code\": response.status_code,\n            \"process_time_ms\": int(process_time * 1000),\n        }\n        logger.info(str(log_data))\n\n        return response\n\n\napp = FastAPI(title=\"Simple Todo API\", version=\"0.1.0\")\n\n# Register middleware\napp.add_middleware(RequestIDMiddleware)\n\n# Include API routes\napp.include_router(todos_router)\n\n\n@app.on_event(\"startup\")\ndef on_startup():\n    \"\"\"\n    Attempt to ensure DB tables exist at startup (useful for dev/demo SQLite).\n    In production with migrations, this is a no-op since migrations should run separately.\n    \"\"\"\n    try:\n        SQLModel.metadata.create_all(engine)\n        logger.info('{\"msg\": \"Database tables ensured\"}')\n    except Exception as e:\n        logger.error(f'{{\"msg\": \"Failed to create DB tables\", \"error\": \"{e}\"}}')\n\n\n# Expose app for ASGI servers (uvicorn)\n# app variable is already defined above and will be picked up by uvicorn."}, {"path": "app/database.py", "content": "import os\nimport logging\nfrom typing import Generator, Optional\n\nfrom sqlmodel import create_engine, Session, SQLModel\n\nlogger = logging.getLogger(__name__)\n\nDATABASE_URL = os.getenv(\"DATABASE_URL\", \"sqlite:///./todos.db\")\n\ndef _is_sqlite_url(url: str) -> bool:\n    return url.startswith(\"sqlite\")\n\n# Decide echo from env\n_sql_echo = os.getenv(\"SQL_ECHO\", \"false\").lower() in (\"1\", \"true\", \"yes\")\n\n_connect_args: Optional[dict] = {\"check_same_thread\": False} if _is_sqlite_url(DATABASE_URL) else None\n\nengine = create_engine(DATABASE_URL, echo=_sql_echo, connect_args=_connect_args or {})\n\ndef get_session() -> Generator[Session, None, None]:\n    \"\"\"\n    FastAPI dependency that yields a SQLModel Session.\n    Usage:\n        from app.database import get_session\n        def endpoint(session: Session = Depends(get_session)):\n            ...\n    \"\"\"\n    session = Session(engine)\n    try:\n        yield session\n    finally:\n        session.close()\n\ndef create_db_and_tables() -> None:\n    \"\"\"\n    Create database tables using SQLModel metadata.\n    Safe to call at startup for SQLite/demo usage. In production with migrations,\n    migrations should be used instead.\n    \"\"\"\n    logger.info(\"Creating database tables (if not exist)\")\n    SQLModel.metadata.create_all(engine)"}, {"path": "app/models.py", "content": "from typing import Optional\nfrom uuid import uuid4\nfrom datetime import datetime, timezone\n\nfrom sqlmodel import SQLModel, Field\nfrom sqlalchemy import (\n    Column,\n    String,\n    Boolean,\n    DateTime,\n    Integer,\n    Text,\n    CheckConstraint,\n    Index,\n)\n\n\ndef _now_utc() -> datetime:\n    return datetime.now(timezone.utc)\n\n\nclass Todo(SQLModel, table=True):\n    \"\"\"\n    SQLModel table model for todos.\n\n    Stores UUID as a string (UUID v4) in the id column.\n    Enforces title length and non-negative priority via CHECK constraints.\n    Provides indexes for created_at, due_date, priority and completed.\n    \"\"\"\n\n    __tablename__ = \"todos\"\n    __table_args__ = (\n        CheckConstraint(\n            \"char_length(title) > 0 AND char_length(title) <= 255\",\n            name=\"ck_title_length\",\n        ),\n        CheckConstraint(\"priority >= 0\", name=\"ck_priority_nonnegative\"),\n        Index(\"idx_todos_created_at\", \"created_at\"),\n        Index(\"idx_todos_due_date\", \"due_date\"),\n        Index(\"idx_todos_priority\", \"priority\"),\n        Index(\"idx_todos_completed\", \"completed\"),\n    )\n\n    id: str = Field(\n        default_factory=lambda: str(uuid4()),\n        primary_key=True,\n        nullable=False,\n        sa_column=Column(\"id\", String(length=36), primary_key=True),\n        description=\"UUID v4 string identifier\",\n    )\n\n    title: str = Field(\n        ...,\n        sa_column=Column(\"title\", String(length=255), nullable=False),\n        description=\"Short title for the todo (1-255 chars)\",\n    )\n\n    description: Optional[str] = Field(\n        None,\n        sa_column=Column(\"description\", Text, nullable=True),\n        description=\"Optional longer description\",\n    )\n\n    completed: bool = Field(\n        default=False,\n        sa_column=Column(\"completed\", Boolean, nullable=False, default=False),\n        description=\"Completion flag\",\n    )\n\n    completed_at: Optional[datetime] = Field(\n        None,\n        sa_column=Column(\"completed_at\", DateTime(timezone=True), nullable=True),\n        description=\"Timestamp when marked completed (UTC)\",\n    )\n\n    due_date: Optional[datetime] = Field(\n        None,\n        sa_column=Column(\"due_date\", DateTime(timezone=True), nullable=True),\n        description=\"Optional due date (UTC)\",\n    )\n\n    priority: int = Field(\n        default=0,\n        sa_column=Column(\"priority\", Integer, nullable=False, default=0),\n        description=\"Non-negative priority (0 = default)\",\n    )\n\n    created_at: datetime = Field(\n        default_factory=_now_utc,\n        sa_column=Column(\"created_at\", DateTime(timezone=True), nullable=False),\n        description=\"Creation timestamp (UTC)\",\n    )\n\n    updated_at: datetime = Field(\n        default_factory=_now_utc,\n        sa_column=Column(\"updated_at\", DateTime(timezone=True), nullable=False),\n        description=\"Last updated timestamp (UTC)\",\n    )"}, {"path": "app/schemas.py", "content": "from __future__ import annotations\n\nfrom datetime import datetime, timezone\nfrom typing import List, Optional\n\nfrom pydantic import BaseModel, Field, validator\n\n\nMAX_TITLE_LENGTH = 255\n\n\ndef _ensure_aware(dt: datetime) -> datetime:\n    if dt.tzinfo is None:\n        # assume UTC if naive\n        return dt.replace(tzinfo=timezone.utc)\n    return dt\n\n\nclass CreateTodo(BaseModel):\n    title: str = Field(..., max_length=MAX_TITLE_LENGTH)\n    description: Optional[str] = None\n    due_date: Optional[datetime] = None\n    priority: int = Field(0, ge=0)\n\n    @validator(\"title\")\n    def title_must_not_be_empty(cls, v: str) -> str:\n        if not v or not v.strip():\n            raise ValueError(\"title must be a non-empty string\")\n        v = v.strip()\n        if len(v) > MAX_TITLE_LENGTH:\n            raise ValueError(f\"title must be at most {MAX_TITLE_LENGTH} characters\")\n        return v\n\n    @validator(\"due_date\", pre=True, always=False)\n    def parse_due_date(cls, v):\n        if v is None:\n            return v\n        if isinstance(v, datetime):\n            return _ensure_aware(v)\n        # Let pydantic coerce strings to datetime where possible; if it fails, pydantic will raise.\n        return v\n\n    class Config:\n        orm_mode = True\n\n\nclass UpdateTodo(BaseModel):\n    # Used for PATCH and PUT endpoints. For PUT the route/service should enforce presence of required fields (title).\n    title: Optional[str] = Field(None, max_length=MAX_TITLE_LENGTH)\n    description: Optional[Optional[str]] = None  # allow explicit null\n    due_date: Optional[Optional[datetime]] = None\n    priority: Optional[int] = Field(None, ge=0)\n    completed: Optional[bool] = None\n\n    @validator(\"title\")\n    def title_must_not_be_empty(cls, v: Optional[str]) -> Optional[str]:\n        if v is None:\n            return v\n        if not v.strip():\n            raise ValueError(\"title must be a non-empty string\")\n        v = v.strip()\n        if len(v) > MAX_TITLE_LENGTH:\n            raise ValueError(f\"title must be at most {MAX_TITLE_LENGTH} characters\")\n        return v\n\n    @validator(\"due_date\", pre=True, always=False)\n    def parse_due_date(cls, v):\n        if v is None:\n            return v\n        if isinstance(v, datetime):\n            return _ensure_aware(v)\n        return v\n\n    class Config:\n        orm_mode = True\n\n\nclass TodoRead(BaseModel):\n    id: str\n    title: str\n    description: Optional[str] = None\n    completed: bool\n    completed_at: Optional[datetime] = None\n    due_date: Optional[datetime] = None\n    priority: int\n    created_at: datetime\n    updated_at: datetime\n\n    @validator(\"created_at\", \"updated_at\", \"completed_at\", \"due_date\", pre=True, always=False)\n    def ensure_dt_aware(cls, v):\n        if v is None:\n            return v\n        if isinstance(v, datetime):\n            return _ensure_aware(v)\n        return v\n\n    class Config:\n        orm_mode = True\n\n\nclass TodoListResponse(BaseModel):\n    items: List[TodoRead]\n    limit: int\n    offset: int\n    total: int\n\n    class Config:\n        orm_mode = True"}, {"path": "app/routes.py", "content": "from typing import List, Optional\nfrom datetime import datetime\n\nfrom fastapi import APIRouter, Depends, HTTPException, status, Response, Query\nfrom sqlalchemy import text\n\nfrom app.database import get_session\nfrom app import service\nfrom app.schemas import CreateTodo, UpdateTodo, TodoRead, TodoListResponse\n\nrouter = APIRouter()\n\n\n@router.get(\"/health\")\ndef health(session=Depends(get_session)):\n    \"\"\"\n    Health endpoint that checks DB connectivity.\n    \"\"\"\n    try:\n        # simple lightweight query to validate DB connectivity\n        session.execute(text(\"SELECT 1\"))\n    except Exception:\n        raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE, detail={\"error\": \"database_unreachable\"})\n    return {\"status\": \"ok\", \"db\": True}\n\n\n@router.get(\"/todos\", response_model=TodoListResponse)\ndef list_todos(\n    completed: Optional[bool] = Query(None),\n    due_before: Optional[datetime] = Query(None),\n    due_after: Optional[datetime] = Query(None),\n    priority: Optional[int] = Query(None, ge=0),\n    limit: int = Query(50, ge=1, le=100),\n    offset: int = Query(0, ge=0),\n    session=Depends(get_session),\n):\n    \"\"\"\n    List todos with optional filters, pagination, and default sorting.\n    \"\"\"\n    try:\n        items, total = service.list_todos(\n            session=session,\n            completed=completed,\n            due_before=due_before,\n            due_after=due_after,\n            priority=priority,\n            limit=limit,\n            offset=offset,\n        )\n    except ValueError as exc:\n        # service may raise ValueError for validation-like issues\n        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail={\"error\": str(exc)})\n    return TodoListResponse(items=items, limit=limit, offset=offset, total=total)\n\n\n@router.post(\"/todos\", response_model=TodoRead, status_code=status.HTTP_201_CREATED)\ndef create_todo(todo_in: CreateTodo, response: Response, session=Depends(get_session)):\n    \"\"\"\n    Create a new todo. Server generates id, timestamps and manages completed/completed_at.\n    \"\"\"\n    try:\n        todo = service.create_todo(session=session, todo_in=todo_in)\n    except ValueError as exc:\n        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail={\"error\": str(exc)})\n\n    # Set Location header to the new resource\n    response.headers[\"Location\"] = f\"/todos/{todo.id}\"\n    return todo\n\n\n@router.get(\"/todos/{todo_id}\", response_model=TodoRead)\ndef get_todo(todo_id: str, session=Depends(get_session)):\n    \"\"\"\n    Retrieve a single todo by id.\n    \"\"\"\n    todo = service.get_todo(session=session, todo_id=todo_id)\n    if not todo:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail={\"error\": \"todo_not_found\"})\n    return todo\n\n\n@router.put(\"/todos/{todo_id}\", response_model=TodoRead)\ndef replace_todo(todo_id: str, todo_in: UpdateTodo, session=Depends(get_session)):\n    \"\"\"\n    Replace a todo (PUT semantics). Client should provide the full resource (server-managed fields are adjusted).\n    \"\"\"\n    try:\n        todo = service.replace_todo(session=session, todo_id=todo_id, todo_in=todo_in)\n    except ValueError as exc:\n        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail={\"error\": str(exc)})\n\n    if not todo:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail={\"error\": \"todo_not_found\"})\n    return todo\n\n\n@router.patch(\"/todos/{todo_id}\", response_model=TodoRead)\ndef patch_todo(todo_id: str, todo_in: UpdateTodo, session=Depends(get_session)):\n    \"\"\"\n    Patch a todo (partial update). Apply completed/completed_at logic server-side.\n    \"\"\"\n    try:\n        todo = service.patch_todo(session=session, todo_id=todo_id, todo_in=todo_in)\n    except ValueError as exc:\n        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail={\"error\": str(exc)})\n\n    if not todo:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail={\"error\": \"todo_not_found\"})\n    return todo\n\n\n@router.delete(\"/todos/{todo_id}\", status_code=status.HTTP_204_NO_CONTENT)\ndef delete_todo(todo_id: str, session=Depends(get_session)):\n    \"\"\"\n    Delete a todo by id.\n    \"\"\"\n    deleted = service.delete_todo(session=session, todo_id=todo_id)\n    if not deleted:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail={\"error\": \"todo_not_found\"})\n    return Response(status_code=status.HTTP_204_NO_CONTENT)"}, {"path": "app/service.py", "content": "from typing import List, Optional, Tuple, Dict, Any\nfrom datetime import datetime, timezone\nfrom uuid import uuid4\n\nfrom fastapi import HTTPException\nfrom sqlmodel import Session, select\nfrom sqlalchemy import func, bindparam\n\nfrom app.models import Todo\nfrom app.schemas import CreateTodo, UpdateTodo\n\nMAX_LIMIT = 100\nDEFAULT_LIMIT = 50\nDEFAULT_OFFSET = 0\n\n\ndef _now() -> datetime:\n    return datetime.now(timezone.utc)\n\n\ndef _sanitize_limit_offset(limit: Optional[int], offset: Optional[int]) -> Tuple[int, int]:\n    # Coerce and validate limit/offset to safe integers\n    try:\n        if limit is None:\n            limit_val = DEFAULT_LIMIT\n        else:\n            limit_val = int(limit)\n    except (TypeError, ValueError):\n        raise HTTPException(status_code=400, detail=\"limit must be an integer\")\n\n    try:\n        if offset is None:\n            offset_val = DEFAULT_OFFSET\n        else:\n            offset_val = int(offset)\n    except (TypeError, ValueError):\n        raise HTTPException(status_code=400, detail=\"offset must be an integer\")\n\n    if limit_val < 0:\n        limit_val = 0\n    limit_val = min(limit_val, MAX_LIMIT)\n    if offset_val < 0:\n        offset_val = 0\n\n    return limit_val, offset_val\n\n\ndef _coerce_bool(value: Any) -> bool:\n    if isinstance(value, bool):\n        return value\n    if isinstance(value, str):\n        v = value.strip().lower()\n        if v in (\"true\", \"1\", \"yes\", \"y\"):\n            return True\n        if v in (\"false\", \"0\", \"no\", \"n\"):\n            return False\n    raise HTTPException(status_code=400, detail=\"completed must be a boolean\")\n\n\ndef create_todo(db: Session, todo_in: CreateTodo) -> Todo:\n    \"\"\"\n    Create a new Todo. Server-managed fields are set here: id, created_at, updated_at,\n    completed (default False) and completed_at (managed by completed).\n    \"\"\"\n    now = _now()\n\n    # Build model instance\n    todo = Todo(\n        id=str(uuid4()),\n        title=todo_in.title,\n        description=getattr(todo_in, \"description\", None),\n        completed=False,\n        completed_at=None,\n        due_date=getattr(todo_in, \"due_date\", None),\n        priority=getattr(todo_in, \"priority\", 0) or 0,\n        created_at=now,\n        updated_at=now,\n    )\n\n    if todo.priority is not None and todo.priority < 0:\n        raise HTTPException(status_code=400, detail=\"priority must be non-negative\")\n\n    with db.begin():\n        db.add(todo)\n        db.flush()  # ensure INSERT executed\n\n    return todo\n\n\ndef get_todo(db: Session, todo_id: str) -> Todo:\n    \"\"\"\n    Retrieve a single Todo by id. Raises 404 if not found.\n    \"\"\"\n    statement = select(Todo).where(Todo.id == todo_id)\n    result = db.exec(statement).first()\n    if not result:\n        raise HTTPException(status_code=404, detail=\"Todo not found\")\n    return result\n\n\ndef list_todos(\n    db: Session,\n    completed: Optional[bool] = None,\n    due_before: Optional[datetime] = None,\n    due_after: Optional[datetime] = None,\n    priority: Optional[int] = None,\n    limit: int = DEFAULT_LIMIT,\n    offset: int = DEFAULT_OFFSET,\n) -> Tuple[List[Todo], int]:\n    \"\"\"\n    List todos with optional filters, pagination, and default sorting (created_at desc).\n    Returns (items, total).\n\n    All inputs are validated and coerced where safe to prevent injection risks.\n    \"\"\"\n    # Validate & coerce pagination params\n    limit, offset = _sanitize_limit_offset(limit, offset)\n\n    # Validate completed\n    if completed is not None:\n        try:\n            completed = _coerce_bool(completed)\n        except HTTPException:\n            # propagate the same error\n            raise\n\n    # Validate due_before / due_after types\n    if due_before is not None and not isinstance(due_before, datetime):\n        raise HTTPException(status_code=400, detail=\"due_before must be an ISO8601 datetime\")\n    if due_after is not None and not isinstance(due_after, datetime):\n        raise HTTPException(status_code=400, detail=\"due_after must be an ISO8601 datetime\")\n\n    # Validate priority\n    if priority is not None:\n        try:\n            priority = int(priority)\n        except (TypeError, ValueError):\n            raise HTTPException(status_code=400, detail=\"priority must be an integer\")\n        if priority < 0:\n            raise HTTPException(status_code=400, detail=\"priority must be non-negative\")\n\n    where_clauses = []\n    # To ensure full parameterization and avoid any dynamic SQL risks, use bindparam with explicit values.\n    if completed is not None:\n        where_clauses.append(Todo.completed == bindparam(\"completed_param\", value=completed))\n    if due_before is not None:\n        where_clauses.append(Todo.due_date <= bindparam(\"due_before_param\", value=due_before))\n    if due_after is not None:\n        where_clauses.append(Todo.due_date >= bindparam(\"due_after_param\", value=due_after))\n    if priority is not None:\n        where_clauses.append(Todo.priority == bindparam(\"priority_param\", value=priority))\n\n    # Total count (parameterized via SQLAlchemy expressions)\n    count_stmt = select(func.count()).select_from(Todo)\n    if where_clauses:\n        count_stmt = count_stmt.where(*where_clauses)\n    total = db.exec(count_stmt).scalar_one()\n\n    # Query items with safe parameterized expressions\n    stmt = select(Todo)\n    if where_clauses:\n        stmt = stmt.where(*where_clauses)\n    stmt = stmt.order_by(Todo.created_at.desc()).offset(offset).limit(limit)\n    items = db.exec(stmt).all()\n\n    return items, int(total)\n\n\ndef replace_todo(db: Session, todo_id: str, todo_in: UpdateTodo) -> Todo:\n    \"\"\"\n    Full replace/PUT semantics. Expects the payload to represent the full resource (title required).\n    Server-managed timestamps and completed_at rules are applied.\n    \"\"\"\n    stmt = select(Todo).where(Todo.id == todo_id).with_for_update()\n    existing = db.exec(stmt).first()\n    if not existing:\n        raise HTTPException(status_code=404, detail=\"Todo not found\")\n\n    data = todo_in.dict(exclude_unset=True)\n\n    # Validate priority if present\n    if \"priority\" in data and data[\"priority\"] is not None and data[\"priority\"] < 0:\n        raise HTTPException(status_code=400, detail=\"priority must be non-negative\")\n    if \"title\" in data:\n        title = data[\"title\"]\n        if not title or len(title) > 255:\n            raise HTTPException(status_code=400, detail=\"title is required and must be 1-255 chars\")\n\n    now = _now()\n\n    # Apply full replace semantics: update provided fields, but treat missing fields as clearing them\n    # For clarity, set fields explicitly\n    existing.title = data.get(\"title\", existing.title)\n    existing.description = data.get(\"description\", None)\n    existing.due_date = data.get(\"due_date\", None)\n    existing.priority = data.get(\"priority\", 0) or 0\n\n    # Completed handling: if client supplied completed flag, obey it and set/clear completed_at accordingly.\n    if \"completed\" in data:\n        new_completed = bool(data[\"completed\"])\n        if new_completed and not existing.completed:\n            existing.completed_at = now\n        if not new_completed:\n            existing.completed_at = None\n        existing.completed = new_completed\n    # If client didn't provide completed in PUT, assume false? For replace we usually expect the client provides it.\n    # But to be safe, if it's missing we'll set to False.\n    elif not hasattr(todo_in, \"completed\"):\n        existing.completed = False\n        existing.completed_at = None\n\n    existing.updated_at = now\n\n    with db.begin():\n        db.add(existing)\n        db.flush()\n\n    return existing\n\n\ndef patch_todo(db: Session, todo_id: str, patch_data: Dict[str, Any]) -> Todo:\n    \"\"\"\n    Partial update/ PATCH semantics. Only provided fields are updated.\n    Completed/completed_at rules applied when completed field is included.\n    \"\"\"\n    stmt = select(Todo).where(Todo.id == todo_id).with_for_update()\n    existing = db.exec(stmt).first()\n    if not existing:\n        raise HTTPException(status_code=404, detail=\"Todo not found\")\n\n    now = _now()\n\n    # Allowed patchable fields\n    allowed_fields = {\"title\", \"description\", \"due_date\", \"priority\", \"completed\"}\n\n    # Validate incoming keys and sanitize by removing unknowns\n    for key in list(patch_data.keys()):\n        if key not in allowed_fields:\n            # ignore unknown keys silently\n            patch_data.pop(key, None)\n\n    if \"priority\" in patch_data and patch_data[\"priority\"] is not None:\n        try:\n            pr = int(patch_data[\"priority\"])\n        except (TypeError, ValueError):\n            raise HTTPException(status_code=400, detail=\"priority must be an integer\")\n        if pr < 0:\n            raise HTTPException(status_code=400, detail=\"priority must be non-negative\")\n        patch_data[\"priority\"] = pr\n\n    if \"title\" in patch_data:\n        title = patch_data[\"title\"]\n        if not title or len(title) > 255:\n            raise HTTPException(status_code=400, detail=\"title is required and must be 1-255 chars\")\n        existing.title = title\n\n    if \"description\" in patch_data:\n        existing.description = patch_data.get(\"description\")\n\n    if \"due_date\" in patch_data:\n        due = patch_data.get(\"due_date\")\n        if due is not None and not isinstance(due, datetime):\n            raise HTTPException(status_code=400, detail=\"due_date must be an ISO8601 datetime\")\n        existing.due_date = due\n\n    if \"priority\" in patch_data:\n        existing.priority = patch_data.get(\"priority\", 0) or 0\n\n    if \"completed\" in patch_data:\n        try:\n            new_completed = _coerce_bool(patch_data[\"completed\"])\n        except HTTPException:\n            raise\n        if new_completed and not existing.completed:\n            existing.completed_at = now\n        if not new_completed:\n            existing.completed_at = None\n        existing.completed = new_completed\n\n    existing.updated_at = now\n\n    with db.begin():\n        db.add(existing)\n        db.flush()\n\n    return existing\n\n\ndef delete_todo(db: Session, todo_id: str) -> None:\n    \"\"\"\n    Delete a todo. Raises 404 if not found. Returns None on success.\n    \"\"\"\n    stmt = select(Todo).where(Todo.id == todo_id).with_for_update()\n    existing = db.exec(stmt).first()\n    if not existing:\n        raise HTTPException(status_code=404, detail=\"Todo not found\")\n\n    with db.begin():\n        db.delete(existing)\n        db.flush()\n\n    return None"}, {"path": "app/auth.py", "content": "import os\nfrom datetime import datetime, timedelta\nfrom typing import Optional, Dict\n\nfrom fastapi import APIRouter, Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm\nfrom jose import JWTError, jwt\nfrom passlib.context import CryptContext\nfrom pydantic import BaseModel\n\nfrom sqlmodel import Field, Session, SQLModel, create_engine, select\nfrom sqlalchemy.exc import SQLAlchemyError\n\n# Security configuration\n# SECRET_KEY must be provided via environment or a secrets file path.\ndef _get_secret_key() -> str:\n    key = os.getenv(\"SECRET_KEY\")\n    if key:\n        return key\n    key_file = os.getenv(\"SECRET_KEY_FILE\")\n    if key_file:\n        try:\n            with open(key_file, \"r\", encoding=\"utf-8\") as f:\n                data = f.read().strip()\n                if data:\n                    return data\n        except Exception as e:\n            raise RuntimeError(f\"Failed to read SECRET_KEY_FILE: {e}\")\n    raise RuntimeError(\n        \"SECRET_KEY is required for token signing. Set SECRET_KEY or SECRET_KEY_FILE environment variable.\"\n    )\n\n\nSECRET_KEY = _get_secret_key()\nALGORITHM = \"HS256\"\nACCESS_TOKEN_EXPIRE_MINUTES = int(os.getenv(\"ACCESS_TOKEN_EXPIRE_MINUTES\", \"60\"))\n\n# Password hashing\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\n# OAuth2 scheme pointing to the token endpoint exposed below\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"/token\")\n\nrouter = APIRouter()\n\n# Database configuration for authentication store\n# A robust DATABASE_URL must be provided (e.g., postgres://user:pass@host:port/dbname).\nAUTH_DATABASE_URL = os.getenv(\"AUTH_DATABASE_URL\")\nif not AUTH_DATABASE_URL:\n    raise RuntimeError(\n        \"AUTH_DATABASE_URL environment variable is required for the authentication database. \"\n        \"Do not rely on a bundled SQLite file for production authentication storage.\"\n    )\n\n# Create engine; SQLModel / SQLAlchemy will be used for DB access.\n# For some drivers (like sqlite) connect_args are necessary, but the\n# environment is expected to provide a production-grade DB URL.\ntry:\n    engine = create_engine(AUTH_DATABASE_URL, echo=False, pool_pre_ping=True)\nexcept Exception as e:\n    raise RuntimeError(f\"Failed to create database engine: {e}\")\n\n# SQLModel table for users\nclass UserTable(SQLModel, table=True):\n    username: str = Field(primary_key=True, index=True)\n    full_name: Optional[str] = None\n    email: Optional[str] = None\n    disabled: bool = False\n    hashed_password: str\n\n\n# Create tables if they do not exist. This is safe for many deployments but in production\n# migrations should be used instead of create_all.\ntry:\n    SQLModel.metadata.create_all(engine)\nexcept Exception as e:\n    raise RuntimeError(f\"Failed to initialize authentication database schema: {e}\")\n\n\n# Schemas\nclass Token(BaseModel):\n    access_token: str\n    token_type: str\n\n\nclass TokenData(BaseModel):\n    username: Optional[str] = None\n\n\nclass User(BaseModel):\n    username: str\n    full_name: Optional[str] = None\n    email: Optional[str] = None\n    disabled: Optional[bool] = False\n\n\nclass UserInDB(User):\n    hashed_password: str\n\n\n# Database-backed user operations using SQLModel sessions\ndef get_user(username: str) -> Optional[UserInDB]:\n    try:\n        with Session(engine) as session:\n            user_row = session.get(UserTable, username)\n            if not user_row:\n                return None\n            return UserInDB(\n                username=user_row.username,\n                full_name=user_row.full_name,\n                email=user_row.email,\n                disabled=user_row.disabled,\n                hashed_password=user_row.hashed_password,\n            )\n    except SQLAlchemyError as e:\n        # Translate DB errors into runtime errors to avoid leaking internals.\n        raise RuntimeError(f\"Database error while retrieving user: {e}\")\n\n\ndef create_user(\n    username: str,\n    password: str,\n    full_name: Optional[str] = None,\n    email: Optional[str] = None,\n    disabled: bool = False,\n) -> UserInDB:\n    hashed = pwd_context.hash(password)\n    try:\n        with Session(engine) as session:\n            user = UserTable(\n                username=username,\n                full_name=full_name,\n                email=email,\n                disabled=bool(disabled),\n                hashed_password=hashed,\n            )\n            session.add(user)\n            session.commit()\n            session.refresh(user)\n            return UserInDB(\n                username=user.username,\n                full_name=user.full_name,\n                email=user.email,\n                disabled=user.disabled,\n                hashed_password=user.hashed_password,\n            )\n    except SQLAlchemyError as e:\n        raise RuntimeError(f\"Database error while creating user: {e}\")\n\n\ndef verify_password(plain_password: str, hashed_password: str) -> bool:\n    try:\n        return pwd_context.verify(plain_password, hashed_password)\n    except Exception:\n        # In case of any verification error, treat as non-match.\n        return False\n\n\ndef authenticate_user(username: str, password: str) -> Optional[UserInDB]:\n    user = get_user(username)\n    if not user:\n        return None\n    if not verify_password(password, user.hashed_password):\n        return None\n    return user\n\n\ndef create_access_token(data: Dict, expires_delta: Optional[timedelta] = None) -> str:\n    to_encode = data.copy()\n    now = datetime.utcnow()\n    if expires_delta:\n        expire = now + expires_delta\n    else:\n        expire = now + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n    # JWT expects numeric timestamps\n    to_encode.update({\"exp\": int(expire.timestamp()), \"iat\": int(now.timestamp())})\n    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\n    return encoded_jwt\n\n\n# Dependencies\nasync def get_current_user(token: str = Depends(oauth2_scheme)) -> User:\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail=\"Could not validate credentials\",\n        headers={\"WWW-Authenticate\": \"Bearer\"},\n    )\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        username: Optional[str] = payload.get(\"sub\")\n        if username is None:\n            raise credentials_exception\n        token_data = TokenData(username=username)\n    except JWTError:\n        raise credentials_exception\n\n    user = get_user(token_data.username)\n    if user is None:\n        raise credentials_exception\n    # Return the public User model\n    return User(**user.dict())\n\n\nasync def get_current_active_user(current_user: User = Depends(get_current_user)) -> User:\n    if current_user.disabled:\n        raise HTTPException(status_code=400, detail=\"Inactive user\")\n    return current_user\n\n\n# Optionally populate a demo user if explicitly requested.\n# This is disabled by default to avoid creating insecure default credentials.\nDEMO_USERNAME = os.getenv(\"DEMO_USERNAME\")\nDEMO_PASSWORD = os.getenv(\"DEMO_PASSWORD\")\nCREATE_DEMO_USER = os.getenv(\"CREATE_DEMO_USER\", \"false\").lower() in (\"1\", \"true\", \"yes\")\n\nif CREATE_DEMO_USER and DEMO_USERNAME and DEMO_PASSWORD:\n    try:\n        # Use create_user which handles hashing and DB interaction\n        create_user(\n            username=DEMO_USERNAME,\n            password=DEMO_PASSWORD,\n            full_name=os.getenv(\"DEMO_FULL_NAME\"),\n            email=os.getenv(\"DEMO_EMAIL\"),\n            disabled=False,\n        )\n    except Exception:\n        # Fail silently here to avoid crashing the entire app on demo creation issues.\n        pass\n\n\n# Token endpoint\n@router.post(\"/token\", response_model=Token)\nasync def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):\n    try:\n        user = authenticate_user(form_data.username, form_data.password)\n    except RuntimeError:\n        # On DB error, report as authentication failure without leaking details.\n        user = None\n\n    if not user:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Incorrect username or password\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n    access_token = create_access_token(\n        data={\"sub\": user.username}, expires_delta=access_token_expires\n    )\n    return {\"access_token\": access_token, \"token_type\": \"bearer\"}"}], "dependencies": ["fastapi", "sqlmodel", "uvicorn", "python-jose[cryptography]", "passlib[bcrypt]"]}