{"files": [{"path": "app/main.py", "content": "from fastapi import FastAPI, Request\nfrom fastapi.responses import JSONResponse\nfrom sqlmodel import SQLModel\n\nfrom app.routes import router as api_router\nfrom app.database import engine\nfrom app import exceptions as exc\n\n\ndef _format_exception_response(err: Exception):\n    # Try to extract useful attributes if present\n    body = {\"error\": str(err)}\n    detail = getattr(err, \"detail\", None)\n    if detail:\n        body[\"detail\"] = detail\n    return body\n\n\napp = FastAPI(title=\"Simple Calculator API\")\n\napp.include_router(api_router)\n\n\n@app.on_event(\"startup\")\ndef on_startup():\n    # Create database tables\n    SQLModel.metadata.create_all(engine)\n\n\n@app.exception_handler(exc.ValidationError)\nasync def validation_exception_handler(request: Request, err: exc.ValidationError):\n    return JSONResponse(status_code=400, content=_format_exception_response(err))\n\n\n@app.exception_handler(exc.EvaluationError)\nasync def evaluation_exception_handler(request: Request, err: exc.EvaluationError):\n    return JSONResponse(status_code=400, content=_format_exception_response(err))\n\n\n@app.exception_handler(exc.NotFoundError)\nasync def not_found_exception_handler(request: Request, err: exc.NotFoundError):\n    return JSONResponse(status_code=404, content=_format_exception_response(err))\n\n\n@app.exception_handler(exc.PersistenceError)\nasync def persistence_exception_handler(request: Request, err: exc.PersistenceError):\n    return JSONResponse(status_code=500, content=_format_exception_response(err))\n\n\n@app.exception_handler(Exception)\nasync def generic_exception_handler(request: Request, err: Exception):\n    # Fallback for unexpected errors\n    return JSONResponse(status_code=500, content={\"error\": \"Internal Server Error\", \"detail\": str(err)})"}, {"path": "app/database.py", "content": "from os import getenv\nfrom typing import Generator\n\nfrom sqlmodel import SQLModel, Session, create_engine\nfrom sqlalchemy.orm import sessionmaker\n\n# Read database URL from environment, fallback to a sensible SQLite file DB.\nDATABASE_URL = getenv(\"DATABASE_URL\", \"sqlite:///./calculations.db\")\n\n# SQLite needs check_same_thread=False when used with multiple threads (FastAPI/uvicorn).\nif DATABASE_URL.startswith(\"sqlite\"):\n    engine = create_engine(DATABASE_URL, connect_args={\"check_same_thread\": False})\nelse:\n    engine = create_engine(DATABASE_URL)\n\n# Session factory using SQLModel's Session class\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine, class_=Session)\n\n\ndef get_session() -> Generator[Session, None, None]:\n    \"\"\"\n    Dependency that provides a SQLModel Session and ensures it is closed after use.\n    Usage in FastAPI endpoints:\n        from fastapi import Depends\n        from app.database import get_session\n        def endpoint(db: Session = Depends(get_session)):\n            ...\n    \"\"\"\n    session = SessionLocal()\n    try:\n        yield session\n    finally:\n        session.close()\n\n\ndef init_db() -> None:\n    \"\"\"\n    Create database tables based on SQLModel metadata.\n    Call this at application startup to ensure tables exist.\n    \"\"\"\n    SQLModel.metadata.create_all(engine)"}, {"path": "app/models.py", "content": "from datetime import datetime\nfrom decimal import Decimal\nfrom typing import Optional, List\nfrom uuid import uuid4\n\nfrom sqlmodel import SQLModel, Field, Column, JSON, Index\nfrom sqlalchemy import String, Numeric, DateTime\n\n\nclass Calculation(SQLModel, table=True):\n    __tablename__ = \"calculations\"\n    __table_args__ = (\n        Index(\"ix_calculation_operator\", \"operator\"),\n        Index(\"ix_calculation_created_at\", \"created_at\"),\n    )\n\n    id: str = Field(\n        default_factory=lambda: str(uuid4()),\n        primary_key=True,\n        sa_column=Column(String(length=36), primary_key=True, nullable=False),\n    )\n    expression: Optional[str] = Field(\n        default=None, sa_column=Column(String, nullable=True)\n    )\n    operator: Optional[str] = Field(\n        default=None, sa_column=Column(String(length=16), nullable=True)\n    )\n    operands: Optional[List[Decimal]] = Field(\n        default=None, sa_column=Column(JSON, nullable=True)\n    )\n    result: Decimal = Field(\n        sa_column=Column(Numeric(38, 16), nullable=False)\n    )\n    error: Optional[str] = Field(\n        default=None, sa_column=Column(String, nullable=True)\n    )\n    created_at: datetime = Field(\n        default_factory=datetime.utcnow,\n        sa_column=Column(DateTime(timezone=True), nullable=False, default=datetime.utcnow),\n    )"}, {"path": "app/schemas.py", "content": "from __future__ import annotations\n\nfrom typing import List, Optional, Any, Dict\nfrom uuid import UUID\nfrom datetime import datetime\nfrom decimal import Decimal, InvalidOperation\n\nfrom pydantic import BaseModel, Field, validator, root_validator, conint\n\n# Configuration defaults (kept local to schemas to avoid external config dependency)\nMAX_EXPRESSION_LENGTH = 1024\nMAX_OPERANDS = 100\nDEFAULT_PRECISION = 8\n\nALLOWED_OPERATORS = {\"+\", \"-\", \"*\", \"/\", \"%\", \"^\"}\n\n\nclass CalculationCreate(BaseModel):\n    \"\"\"\n    Request model for calculation endpoint.\n    Provide either `expression` OR (`operator` and `operands`).\n    \"\"\"\n\n    expression: Optional[str] = Field(\n        None, description=\"Mathematical expression to evaluate (e.g. '2+2*3')\"\n    )\n    operator: Optional[str] = Field(\n        None, description=\"Operator for operator-based calculation (e.g. '+')\"\n    )\n    operands: Optional[List[Decimal]] = Field(\n        None, description=\"List of numeric operands for operator-based calculation\"\n    )\n\n    # Validation: ensure either expression or operator+operands, not both\n    @root_validator\n    def check_exclusive_inputs(cls, values: Dict[str, Any]) -> Dict[str, Any]:\n        expression = values.get(\"expression\")\n        operator = values.get(\"operator\")\n        operands = values.get(\"operands\")\n\n        if expression:\n            # If expression provided, operator/operands must not be present\n            if operator is not None or operands is not None:\n                raise ValueError(\n                    \"Provide either 'expression' OR 'operator' with 'operands', not both.\"\n                )\n            # enforce max expression length\n            if len(expression) > MAX_EXPRESSION_LENGTH:\n                raise ValueError(\n                    f\"Expression length exceeds maximum of {MAX_EXPRESSION_LENGTH} characters.\"\n                )\n        else:\n            # No expression: operator and operands required\n            if not operator or operands is None:\n                raise ValueError(\"When 'expression' is not provided, 'operator' and 'operands' are required.\")\n\n        return values\n\n    @validator(\"operator\")\n    def validate_operator(cls, v: Optional[str]) -> Optional[str]:\n        if v is None:\n            return v\n        if v not in ALLOWED_OPERATORS:\n            raise ValueError(f\"Unsupported operator '{v}'. Allowed operators: {sorted(ALLOWED_OPERATORS)}\")\n        return v\n\n    @validator(\"operands\", pre=True)\n    def validate_and_convert_operands(cls, v: Optional[List[Any]]) -> Optional[List[Decimal]]:\n        if v is None:\n            return v\n        if not isinstance(v, list):\n            raise ValueError(\"Operands must be a list of numeric values.\")\n        if len(v) > MAX_OPERANDS:\n            raise ValueError(f\"Number of operands exceeds maximum of {MAX_OPERANDS}.\")\n        # Enforce binary arity by default (require exactly 2 operands)\n        if len(v) != 2:\n            raise ValueError(\"Operator-based requests require exactly 2 operands.\")\n        converted: List[Decimal] = []\n        for idx, item in enumerate(v):\n            try:\n                # Use Decimal(str(...)) to avoid float imprecision when converting floats\n                if isinstance(item, Decimal):\n                    converted.append(item)\n                else:\n                    converted.append(Decimal(str(item)))\n            except (InvalidOperation, ValueError, TypeError):\n                raise ValueError(f\"Operand at index {idx} is not a valid number: {item!r}\")\n        return converted\n\n    class Config:\n        anystr_strip_whitespace = True\n        schema_extra = {\n            \"examples\": [\n                {\"expression\": \"2+2*3\"},\n                {\"operator\": \"+\", \"operands\": [1, 2]},\n            ]\n        }\n\n\nclass CalculationResponse(BaseModel):\n    id: UUID\n    expression: Optional[str] = None\n    operator: Optional[str] = None\n    operands: Optional[List[Decimal]] = None\n    result: Decimal\n    error: Optional[str] = None\n    created_at: datetime\n\n    class Config:\n        orm_mode = True\n        json_encoders = {\n            Decimal: lambda d: str(d),\n            datetime: lambda dt: dt.isoformat(),\n        }\n\n\nclass CalculationListQuery(BaseModel):\n    limit: conint(ge=1, le=1000) = Field(100, description=\"Maximum number of items to return\")\n    offset: conint(ge=0) = Field(0, description=\"Offset for pagination\")\n    operator: Optional[str] = Field(None, description=\"Filter by operator symbol\")\n    from_: Optional[datetime] = Field(None, alias=\"from\", description=\"Start created_at datetime (inclusive)\")\n    to: Optional[datetime] = Field(None, alias=\"to\", description=\"End created_at datetime (inclusive)\")\n\n    @validator(\"operator\")\n    def validate_operator_filter(cls, v: Optional[str]) -> Optional[str]:\n        if v is None:\n            return v\n        if v not in ALLOWED_OPERATORS:\n            raise ValueError(f\"Unsupported operator filter '{v}'. Allowed: {sorted(ALLOWED_OPERATORS)}\")\n        return v\n\n    class Config:\n        allow_population_by_field_name = True\n\n\nclass CalculationListResponse(BaseModel):\n    items: List[CalculationResponse]\n    total: Optional[int] = None\n\n\nclass OperatorsResponse(BaseModel):\n    operators: List[Dict[str, Any]] = Field(\n        ..., description=\"List of supported operators with metadata\"\n    )\n\n    @staticmethod\n    def default() -> \"OperatorsResponse\":\n        ops = [\n            {\"symbol\": \"+\", \"arity\": \"binary\", \"description\": \"Addition; also supports variadic addition when used as expression.\"},\n            {\"symbol\": \"-\", \"arity\": \"binary\", \"description\": \"Subtraction\"},\n            {\"symbol\": \"*\", \"arity\": \"binary\", \"description\": \"Multiplication; also supports variadic multiplication in expressions.\"},\n            {\"symbol\": \"/\", \"arity\": \"binary\", \"description\": \"Division (division by zero raises an error)\"},\n            {\"symbol\": \"%\", \"arity\": \"binary\", \"description\": \"Modulo\"},\n            {\"symbol\": \"^\", \"arity\": \"binary\", \"description\": \"Exponentiation (caret '^' is accepted in requests and treated as power).\"},\n        ]\n        return OperatorsResponse(operators=ops)\n\n\nclass DeleteSummary(BaseModel):\n    deleted: int = Field(..., description=\"Number of deleted records\")"}, {"path": "app/routes.py", "content": "from typing import Optional, List\nfrom uuid import UUID\nfrom datetime import datetime\n\nfrom fastapi import APIRouter, Depends, Query, HTTPException, status\nfrom sqlmodel import Session\n\nfrom app.database import get_session\nfrom app import services\nfrom app import schemas\nfrom app import exceptions\n\nrouter = APIRouter()\n\n\n@router.post(\"/calculate\", response_model=schemas.CalculationResponse)\ndef calculate(\n    payload: schemas.CalculationRequest,\n    store: bool = Query(True, description=\"Whether to persist the calculation result\"),\n    db: Session = Depends(get_session),\n):\n    \"\"\"\n    Evaluate an expression or operator+operands request and optionally store the result.\n    \"\"\"\n    try:\n        result = services.evaluate_calculation(db=db, request=payload, store=store)\n        return result\n    except (exceptions.ValidationError, exceptions.EvaluationError, exceptions.PersistenceError) as exc:\n        # Let main.py's exception handlers deal with domain exceptions if registered;\n        # but raise HTTP 400 for validation/evaluation and 500 for persistence as fallback.\n        if isinstance(exc, (exceptions.ValidationError, exceptions.EvaluationError)):\n            raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))\n        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(exc))\n\n\n@router.get(\"/calculations\", response_model=List[schemas.CalculationResponse])\ndef list_calculations(\n    limit: int = Query(100, ge=1, le=1000),\n    offset: int = Query(0, ge=0),\n    operator: Optional[str] = Query(None, description=\"Filter by operator\"),\n    from_ts: Optional[datetime] = Query(None, alias=\"from\", description=\"Start datetime (inclusive)\"),\n    to_ts: Optional[datetime] = Query(None, alias=\"to\", description=\"End datetime (inclusive)\"),\n    db: Session = Depends(get_session),\n):\n    \"\"\"\n    List calculation history with optional filters.\n    \"\"\"\n    filters = {\n        \"operator\": operator,\n        \"from\": from_ts,\n        \"to\": to_ts,\n        \"limit\": limit,\n        \"offset\": offset,\n    }\n    try:\n        results = services.list_calculations(db=db, filters=filters)\n        return results\n    except exceptions.PersistenceError as exc:\n        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(exc))\n\n\n@router.get(\"/calculations/{calculation_id}\", response_model=schemas.CalculationResponse)\ndef get_calculation(\n    calculation_id: UUID,\n    db: Session = Depends(get_session),\n):\n    \"\"\"\n    Retrieve a single calculation by id.\n    \"\"\"\n    try:\n        calc = services.get_calculation(db=db, calculation_id=calculation_id)\n        if calc is None:\n            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Calculation not found\")\n        return calc\n    except exceptions.PersistenceError as exc:\n        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(exc))\n\n\n@router.delete(\"/calculations/{calculation_id}\")\ndef delete_calculation(\n    calculation_id: UUID,\n    db: Session = Depends(get_session),\n):\n    \"\"\"\n    Delete a specific calculation by id.\n    \"\"\"\n    try:\n        deleted = services.delete_calculation(db=db, calculation_id=calculation_id)\n        if not deleted:\n            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Calculation not found\")\n        return {\"deleted\": True, \"id\": str(calculation_id)}\n    except exceptions.PersistenceError as exc:\n        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(exc))\n\n\n@router.delete(\"/calculations\")\ndef clear_calculations(\n    db: Session = Depends(get_session),\n):\n    \"\"\"\n    Clear entire calculation history. Returns count deleted.\n    \"\"\"\n    try:\n        count = services.clear_calculations(db=db)\n        return {\"deleted_count\": count}\n    except exceptions.PersistenceError as exc:\n        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(exc))\n\n\n@router.get(\"/operators\")\ndef operators():\n    \"\"\"\n    Return supported operators and constraints.\n    \"\"\"\n    ops = services.get_operators()\n    return ops\n\n\n@router.get(\"/health\")\ndef health(db: Session = Depends(get_session)):\n    \"\"\"\n    Simple health check. Optionally checks DB connectivity.\n    \"\"\"\n    try:\n        ok = services.health_check(db=db)\n        return {\"status\": \"ok\", \"db\": ok}\n    except Exception as exc:\n        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(exc))"}, {"path": "app/services.py", "content": "from __future__ import annotations\n\nimport ast\nimport logging\nimport os\nimport uuid\nfrom contextlib import contextmanager\nfrom datetime import datetime\nfrom decimal import Decimal, DivisionByZero, InvalidOperation, ROUND_HALF_EVEN, getcontext\nfrom typing import Any, Dict, List, Optional, Tuple, Union\n\nfrom sqlmodel import Session, select\n\nfrom app.exceptions import EvaluationError, NotFoundError, PersistenceError, ValidationError\nfrom app.models import Calculation\n\nlogger = logging.getLogger(__name__)\nlogging.basicConfig(level=logging.INFO)\n\n# Configuration via environment with sensible defaults\nPRECISION: int = int(os.getenv(\"PRECISION\", \"8\"))\nMAX_EXPRESSION_LENGTH: int = int(os.getenv(\"MAX_EXPRESSION_LENGTH\", \"1024\"))\nMAX_OPERANDS: int = int(os.getenv(\"MAX_OPERANDS\", \"100\"))\nSTORE_BY_DEFAULT: bool = os.getenv(\"STORE_BY_DEFAULT\", \"true\").lower() in (\"1\", \"true\", \"yes\")\n\n# Supported operators (module-level constant used for validation to avoid injecting user input into raw SQL)\nSUPPORTED_OPERATORS = {\"+\", \"-\", \"*\", \"/\", \"%\", \"^\"}\n\n# Configure global Decimal context precision slightly higher than quantize to avoid intermediate rounding issues\ngetcontext().prec = max(28, PRECISION + 10)\n\n\ndef sanitize_operator(operator: Optional[Any]) -> Optional[str]:\n    \"\"\"\n    Ensure operator is a string, stripped, and is in the supported whitelist.\n    Returns the cleaned operator string or None.\n    Raises ValidationError on invalid input.\n    \"\"\"\n    if operator is None:\n        return None\n    if not isinstance(operator, str):\n        raise ValidationError(\"Operator must be a string\")\n    op_clean = operator.strip()\n    if op_clean not in SUPPORTED_OPERATORS:\n        raise ValidationError(f\"Operator '{op_clean}' is not supported\")\n    return op_clean\n\n\nclass SafeEvaluator(ast.NodeVisitor):\n    \"\"\"\n    AST-based safe expression evaluator that computes using Decimal.\n    Allowed nodes: Expression, BinOp, UnaryOp, Constant/Num, specific operators.\n    \"\"\"\n\n    ALLOWED_BINOPS = {\n        ast.Add,\n        ast.Sub,\n        ast.Mult,\n        ast.Div,\n        ast.Mod,\n        ast.Pow,\n    }\n    ALLOWED_UNARYOPS = {ast.UAdd, ast.USub}\n\n    def __init__(self) -> None:\n        super().__init__()\n\n    def evaluate(self, expression: str) -> Decimal:\n        if not isinstance(expression, str):\n            raise EvaluationError(\"Expression must be a string\")\n        # Preprocess: support '^' as exponentiation\n        normalized = expression.replace(\"^\", \"**\")\n        if len(normalized) > MAX_EXPRESSION_LENGTH:\n            raise ValidationError(f\"Expression exceeds maximum length of {MAX_EXPRESSION_LENGTH}\")\n        try:\n            node = ast.parse(normalized, mode=\"eval\")\n        except SyntaxError as exc:\n            raise ValidationError(f\"Syntax error in expression: {exc}\") from exc\n\n        return self._eval(node)\n\n    def _eval(self, node: ast.AST) -> Decimal:\n        # Entry point expects Expression node\n        if isinstance(node, ast.Expression):\n            return self._eval(node.body)\n        return self.visit(node)\n\n    def visit_BinOp(self, node: ast.BinOp) -> Decimal:\n        if type(node.op) not in self.ALLOWED_BINOPS:\n            raise EvaluationError(f\"Operator {type(node.op).__name__} is not allowed\")\n        left = self._eval(node.left)\n        right = self._eval(node.right)\n\n        try:\n            if isinstance(node.op, ast.Add):\n                return left + right\n            if isinstance(node.op, ast.Sub):\n                return left - right\n            if isinstance(node.op, ast.Mult):\n                return left * right\n            if isinstance(node.op, ast.Div):\n                if right == Decimal(\"0\"):\n                    raise EvaluationError(\"Division by zero\")\n                return left / right\n            if isinstance(node.op, ast.Mod):\n                if right == Decimal(\"0\"):\n                    raise EvaluationError(\"Division by zero in modulo\")\n                return left % right\n            if isinstance(node.op, ast.Pow):\n                # Try integer exponent first for safety\n                if right == right.to_integral_value():\n                    # integer exponent\n                    try:\n                        exp_int = int(right)\n                        # pow with negative integer is allowed (produces Decimal)\n                        return left.__pow__(exp_int)\n                    except (OverflowError, ValueError, InvalidOperation):\n                        # fallback to Decimal power (may still raise)\n                        pass\n                # For non-integer exponents, attempt using Decimal power (may raise InvalidOperation)\n                try:\n                    return left.__pow__(right)\n                except (InvalidOperation, TypeError) as exc:\n                    # If Decimal can't handle, raise EvaluationError with details\n                    raise EvaluationError(f\"Invalid exponentiation: {exc}\") from exc\n        except DivisionByZero:\n            raise EvaluationError(\"Division by zero\")\n        except InvalidOperation as exc:\n            raise EvaluationError(f\"Invalid numeric operation: {exc}\") from exc\n\n        raise EvaluationError(\"Unsupported binary operation\")\n\n    def visit_UnaryOp(self, node: ast.UnaryOp) -> Decimal:\n        if type(node.op) not in self.ALLOWED_UNARYOPS:\n            raise EvaluationError(f\"Unary operator {type(node.op).__name__} not allowed\")\n        operand = self._eval(node.operand)\n        if isinstance(node.op, ast.UAdd):\n            return operand\n        if isinstance(node.op, ast.USub):\n            return -operand\n        raise EvaluationError(\"Unsupported unary operation\")\n\n    def visit_Constant(self, node: ast.Constant) -> Decimal:\n        value = node.value\n        if isinstance(value, (int, float, Decimal)):\n            try:\n                # Convert using str to avoid float binary representation leakage\n                return Decimal(str(value))\n            except (InvalidOperation, ValueError) as exc:\n                raise EvaluationError(f\"Invalid numeric literal: {value}\") from exc\n        raise EvaluationError(f\"Unsupported constant type: {type(value).__name__}\")\n\n    # For compatibility with older AST where Num exists\n    def visit_Num(self, node: ast.Num) -> Decimal:\n        return self.visit_Constant(node)\n\n    def generic_visit(self, node: ast.AST) -> Decimal:\n        raise EvaluationError(f\"Unsupported expression element: {type(node).__name__}\")\n\n\nclass CalculatorService:\n    \"\"\"\n    Coordinates validation, safe evaluation, rounding, and persistence.\n    \"\"\"\n\n    def __init__(self, evaluator: Optional[SafeEvaluator] = None) -> None:\n        self.evaluator = evaluator or SafeEvaluator()\n        self.precision = PRECISION\n\n    def _quantize(self, value: Decimal) -> Decimal:\n        quant = Decimal(10) ** (-self.precision)\n        try:\n            return value.quantize(quant, rounding=ROUND_HALF_EVEN)\n        except (InvalidOperation, ValueError) as exc:\n            raise EvaluationError(f\"Failed to quantize result: {exc}\") from exc\n\n    def _validate_operator(self, operator: Any) -> str:\n        \"\"\"\n        Validate and return a sanitized operator string.\n        \"\"\"\n        sanitized = sanitize_operator(operator)\n        # sanitize_operator raises ValidationError for invalid input, and returns None for None.\n        if sanitized is None:\n            raise ValidationError(\"Operator must be provided\")\n        return sanitized\n\n    def _convert_operands(self, operands: List[Any]) -> List[Decimal]:\n        if len(operands) > MAX_OPERANDS:\n            raise ValidationError(f\"Too many operands; maximum is {MAX_OPERANDS}\")\n        converted: List[Decimal] = []\n        for idx, v in enumerate(operands):\n            try:\n                converted.append(Decimal(str(v)))\n            except (InvalidOperation, ValueError) as exc:\n                raise ValidationError(f\"Operand at index {idx} is not numeric: {v}\") from exc\n        return converted\n\n    def _apply_operator(self, operator: str, operands: List[Decimal]) -> Decimal:\n        # Default: enforce binary operators\n        if len(operands) != 2:\n            raise ValidationError(f\"Operator '{operator}' requires exactly 2 operands\")\n        a, b = operands\n        try:\n            if operator == \"+\":\n                return a + b\n            if operator == \"-\":\n                return a - b\n            if operator == \"*\":\n                return a * b\n            if operator == \"/\":\n                if b == Decimal(\"0\"):\n                    raise EvaluationError(\"Division by zero\")\n                return a / b\n            if operator == \"%\":\n                if b == Decimal(\"0\"):\n                    raise EvaluationError(\"Division by zero in modulo\")\n                return a % b\n            if operator == \"^\":\n                # attempt integer exponent optimization\n                if b == b.to_integral_value():\n                    try:\n                        return a.__pow__(int(b))\n                    except (OverflowError, InvalidOperation):\n                        pass\n                try:\n                    return a.__pow__(b)\n                except InvalidOperation as exc:\n                    raise EvaluationError(f\"Invalid exponentiation: {exc}\") from exc\n        except DivisionByZero:\n            raise EvaluationError(\"Division by zero\")\n        except InvalidOperation as exc:\n            raise EvaluationError(f\"Invalid numeric operation: {exc}\") from exc\n\n        raise EvaluationError(f\"Unsupported operator '{operator}'\")\n\n    def evaluate(\n        self,\n        *,\n        expression: Optional[str] = None,\n        operator: Optional[str] = None,\n        operands: Optional[List[Any]] = None,\n        store: Optional[bool] = None,\n        session: Optional[Session] = None,\n    ) -> Calculation:\n        \"\"\"\n        Evaluate either an expression or operator+operands. Optionally persist the result.\n        Returns a Calculation model (not necessarily persisted if store is False).\n        \"\"\"\n        store_flag = STORE_BY_DEFAULT if store is None else bool(store)\n\n        # Validate mutually exclusive input\n        if expression and (operator or operands):\n            raise ValidationError(\"Provide either 'expression' OR 'operator'+'operands', not both\")\n        if not expression and not (operator and operands):\n            raise ValidationError(\"Must provide either 'expression' or 'operator' with 'operands'\")\n\n        result: Decimal\n        error_msg: Optional[str] = None\n        normalized_expression: Optional[str] = None\n        used_operator: Optional[str] = None\n        used_operands: Optional[List[Decimal]] = None\n\n        try:\n            if expression is not None:\n                normalized_expression = expression.replace(\"^\", \"**\")\n                if len(normalized_expression) > MAX_EXPRESSION_LENGTH:\n                    raise ValidationError(f\"Expression exceeds maximum length of {MAX_EXPRESSION_LENGTH}\")\n                result = self.evaluator.evaluate(expression)\n            else:\n                # operator and operands provided\n                assert operator is not None and operands is not None\n                # Validate and sanitize operator early before any use\n                used_operator = self._validate_operator(operator)\n                used_operands = self._convert_operands(operands)\n                result = self._apply_operator(used_operator, used_operands)\n        except (ValidationError, EvaluationError):\n            raise\n        except Exception as exc:\n            # Wrap unexpected exceptions as EvaluationError\n            logger.exception(\"Unexpected error during evaluation\")\n            raise EvaluationError(f\"Evaluation failed: {exc}\") from exc\n\n        # Quantize/round result\n        quantized = self._quantize(result)\n\n        # Build Calculation instance\n        calc = Calculation(\n            id=uuid.uuid4(),\n            expression=expression if expression is not None else None,\n            operator=used_operator,\n            operands=[str(x) for x in used_operands] if used_operands is not None else None,\n            result=quantized,\n            error=error_msg,\n            created_at=datetime.utcnow(),\n        )\n\n        # Before any database interaction, ensure operator is validated to prevent injection via operator field.\n        if calc.operator is not None:\n            # sanitize and reassign canonical operator\n            calc.operator = self._validate_operator(calc.operator)\n\n        # Persist if requested\n        if store_flag:\n            if session is None:\n                raise PersistenceError(\"No database session provided for storing calculation\")\n            try:\n                persisted = create_calculation(session=session, calculation=calc)\n                return persisted\n            except Exception as exc:\n                logger.exception(\"Failed to persist calculation\")\n                raise PersistenceError(f\"Failed to persist calculation: {exc}\") from exc\n\n        return calc\n\n\n# Repository functions operating with SQLModel sessions\n\n\ndef create_calculation(*, session: Session, calculation: Calculation) -> Calculation:\n    # Validate operator at repository boundary as an extra safeguard before any DB query usage.\n    if calculation.operator is not None:\n        # sanitize and ensure operator is canonical before persisting\n        calculation.operator = sanitize_operator(calculation.operator)\n    try:\n        session.add(calculation)\n        session.commit()\n        session.refresh(calculation)\n        return calculation\n    except Exception as exc:\n        session.rollback()\n        logger.exception(\"create_calculation failed\")\n        raise PersistenceError(f\"Failed to create calculation: {exc}\") from exc\n\n\ndef get_calculation_by_id(*, session: Session, calculation_id: Union[str, uuid.UUID]) -> Calculation:\n    try:\n        calc_id = uuid.UUID(str(calculation_id))\n    except Exception:\n        raise ValidationError(\"Invalid UUID for calculation id\")\n    statement = select(Calculation).where(Calculation.id == calc_id)\n    result = session.exec(statement).first()\n    if not result:\n        raise NotFoundError(\"Calculation not found\")\n    return result\n\n\ndef list_calculations(\n    *,\n    session: Session,\n    limit: int = 100,\n    offset: int = 0,\n    operator: Optional[str] = None,\n    from_dt: Optional[datetime] = None,\n    to_dt: Optional[datetime] = None,\n) -> List[Calculation]:\n    # Validate operator against supported set to avoid any potential injection or unexpected filtering behavior.\n    operator_clean = sanitize_operator(operator) if operator is not None else None\n\n    statement = select(Calculation).order_by(Calculation.created_at.desc())\n    if operator_clean:\n        # Using SQLAlchemy/SQLModel style comparisons ensures parameterized queries.\n        statement = statement.where(Calculation.operator == operator_clean)\n    if from_dt:\n        statement = statement.where(Calculation.created_at >= from_dt)\n    if to_dt:\n        statement = statement.where(Calculation.created_at <= to_dt)\n    statement = statement.offset(max(0, offset)).limit(max(1, limit))\n    results = session.exec(statement).all()\n    return results\n\n\ndef delete_calculation_by_id(*, session: Session, calculation_id: Union[str, uuid.UUID]) -> Dict[str, Any]:\n    try:\n        calc = get_calculation_by_id(session=session, calculation_id=calculation_id)\n    except NotFoundError:\n        raise\n    try:\n        session.delete(calc)\n        session.commit()\n        return {\"deleted\": 1, \"id\": str(calc.id)}\n    except Exception as exc:\n        session.rollback()\n        logger.exception(\"Failed to delete calculation\")\n        raise PersistenceError(f\"Failed to delete calculation: {exc}\") from exc\n\n\ndef clear_all_calculations(*, session: Session) -> Dict[str, Any]:\n    try:\n        statement = select(Calculation)\n        all_items = session.exec(statement).all()\n        count = 0\n        for item in all_items:\n            session.delete(item)\n            count += 1\n        session.commit()\n        return {\"deleted\": count}\n    except Exception as exc:\n        session.rollback()\n        logger.exception(\"Failed to clear calculations\")\n        raise PersistenceError(f\"Failed to clear calculations: {exc}\") from exc"}, {"path": "app/exceptions.py", "content": "from typing import Any, Dict, Optional\n\n\nclass ApplicationError(Exception):\n    \"\"\"\n    Base class for domain/application errors.\n\n    Attributes:\n        message: Short human-readable error message.\n        detail: Optional structured detail (can be string, dict, list) for more context.\n    \"\"\"\n\n    def __init__(self, message: str, detail: Optional[Any] = None) -> None:\n        super().__init__(message)\n        self.message = message\n        self.detail = detail\n\n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"\n        Convert the error into a serializable dictionary suitable for JSON responses.\n        \"\"\"\n        payload: Dict[str, Any] = {\"error\": self.message}\n        if self.detail is not None:\n            payload[\"detail\"] = self.detail\n        return payload\n\n    def __str__(self) -> str:\n        if self.detail is not None:\n            return f\"{self.message} - Detail: {self.detail}\"\n        return self.message\n\n\nclass ValidationError(ApplicationError):\n    \"\"\"\n    Raised when input validation fails (bad request).\n    \"\"\"\n\n\nclass EvaluationError(ApplicationError):\n    \"\"\"\n    Raised when evaluation of an expression or operator-based calculation fails,\n    e.g., division by zero, unsupported tokens, or other runtime errors during evaluation.\n    \"\"\"\n\n\nclass PersistenceError(ApplicationError):\n    \"\"\"\n    Raised when there is a failure saving to or reading from the persistence layer.\n    \"\"\"\n\n\nclass NotFoundError(ApplicationError):\n    \"\"\"\n    Raised when a requested resource (e.g., Calculation by id) is not found.\n    \"\"\""}, {"path": "app/auth.py", "content": "from datetime import datetime, timedelta\nimport os\nimport logging\nimport secrets\nfrom typing import Optional, Dict, Any\n\nfrom fastapi import Depends, HTTPException, status, APIRouter\nfrom fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm\nfrom pydantic import BaseModel\nfrom jose import JWTError, jwt\nfrom passlib.context import CryptContext\n\nfrom sqlmodel import SQLModel, Field, create_engine, Session, select\n\nlogger = logging.getLogger(__name__)\n\n# JWT secret handling: prefer an explicit environment variable but fall back to a generated ephemeral secret.\n# Using an ephemeral secret avoids crashing the application while making it explicit that this is insecure\n# for production (tokens will be invalidated on restart).\nSECRET_KEY = os.environ.get(\"JWT_SECRET_KEY\")\nif not SECRET_KEY:\n    SECRET_KEY = secrets.token_urlsafe(32)\n    logger.warning(\n        \"JWT_SECRET_KEY is not set in the environment. An ephemeral secret key has been generated. \"\n        \"This is insecure for production and tokens will be invalidated when the process restarts.\"\n    )\n\nALGORITHM = \"HS256\"\nACCESS_TOKEN_EXPIRE_MINUTES = int(os.environ.get(\"ACCESS_TOKEN_EXPIRE_MINUTES\", \"30\"))\n\n# Database for users (simple SQLite by default; in production use a managed DB)\nDATABASE_URL = os.environ.get(\"DATABASE_URL\", \"sqlite:///./users.db\")\nengine = create_engine(DATABASE_URL, echo=False)\n\n# Password hashing\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\n# OAuth2 scheme (tokenUrl must match the token route defined below)\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"/token\")\n\nrouter = APIRouter()\n\n\nclass Token(BaseModel):\n    access_token: str\n    token_type: str\n    expires_at: datetime\n\n\nclass TokenData(BaseModel):\n    username: Optional[str] = None\n\n\nclass User(BaseModel):\n    username: str\n    disabled: Optional[bool] = False\n\n\nclass UserInDB(User):\n    hashed_password: str\n\n\nclass UserTable(SQLModel, table=True):\n    id: Optional[int] = Field(default=None, primary_key=True)\n    username: str = Field(index=True)\n    hashed_password: str\n    disabled: bool = Field(default=False)\n\n\n# Create users table if not exists\nSQLModel.metadata.create_all(engine)\n\n\ndef verify_password(plain_password: str, hashed_password: str) -> bool:\n    return pwd_context.verify(plain_password, hashed_password)\n\n\ndef get_password_hash(password: str) -> str:\n    return pwd_context.hash(password)\n\n\ndef get_user(username: str) -> Optional[UserInDB]:\n    \"\"\"\n    Retrieve a user from the users database.\n    Returns UserInDB or None if not found.\n    \"\"\"\n    with Session(engine) as session:\n        statement = select(UserTable).where(UserTable.username == username)\n        user_row = session.exec(statement).first()\n        if not user_row:\n            return None\n        return UserInDB(username=user_row.username, hashed_password=user_row.hashed_password, disabled=user_row.disabled)\n\n\ndef create_user(username: str, password: str, disabled: bool = False) -> UserInDB:\n    \"\"\"\n    Create a new user in the database.\n\n    Raises:\n        ValueError: If a user with the given username already exists.\n    \"\"\"\n    # Ensure username uniqueness at application level\n    existing = get_user(username)\n    if existing is not None:\n        raise ValueError(f\"User with username '{username}' already exists.\")\n\n    hashed = get_password_hash(password)\n    user = UserTable(username=username, hashed_password=hashed, disabled=disabled)\n    with Session(engine) as session:\n        session.add(user)\n        session.commit()\n        session.refresh(user)\n    return UserInDB(username=user.username, hashed_password=user.hashed_password, disabled=user.disabled)\n\n\ndef authenticate_user(username: str, password: str) -> Optional[UserInDB]:\n    \"\"\"\n    Verify username/password against the database.\n    \"\"\"\n    user = get_user(username)\n    if not user:\n        return None\n    if not verify_password(password, user.hashed_password):\n        return None\n    return user\n\n\ndef create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:\n    to_encode = data.copy()\n    now = datetime.utcnow()\n    if expires_delta:\n        expire = now + expires_delta\n    else:\n        expire = now + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n    # Use numeric timestamps for standard JWT exp/iAt claims\n    to_encode.update({\"exp\": int(expire.timestamp()), \"iat\": int(now.timestamp())})\n    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\n    return encoded_jwt\n\n\n@router.post(\"/token\", response_model=Token)\nasync def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):\n    \"\"\"\n    Token endpoint compatible with OAuth2PasswordRequestForm.\n    Returns a JWT access token with 'sub' claim set to the username.\n    \"\"\"\n    user = authenticate_user(form_data.username, form_data.password)\n    if not user:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Incorrect username or password\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n    access_token = create_access_token(\n        data={\"sub\": user.username}, expires_delta=access_token_expires\n    )\n    expires_at = datetime.utcnow() + access_token_expires\n    return {\"access_token\": access_token, \"token_type\": \"bearer\", \"expires_at\": expires_at}\n\n\nasync def get_current_user(token: str = Depends(oauth2_scheme)) -> User:\n    \"\"\"\n    Dependency to retrieve the current user from the provided JWT token.\n    Raises 401 if token is invalid or user not found.\n    \"\"\"\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail=\"Could not validate credentials\",\n        headers={\"WWW-Authenticate\": \"Bearer\"},\n    )\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        username: Optional[str] = payload.get(\"sub\")\n        if username is None:\n            raise credentials_exception\n        token_data = TokenData(username=username)\n    except JWTError:\n        raise credentials_exception\n    user = get_user(token_data.username)\n    if user is None:\n        raise credentials_exception\n    return User(username=user.username, disabled=user.disabled)\n\n\nasync def get_current_active_user(current_user: User = Depends(get_current_user)) -> User:\n    \"\"\"\n    Dependency that ensures the current user is active (not disabled).\n    \"\"\"\n    if current_user.disabled:\n        raise HTTPException(status_code=400, detail=\"Inactive user\")\n    return current_user\n\n\n# Convenience: allow creating an initial admin via env vars (optional)\n# Require ADMIN_PASSWORD to be explicitly set when SEED_DEFAULT_USERS=1 to avoid insecure defaults\nif os.environ.get(\"SEED_DEFAULT_USERS\", \"0\") == \"1\":\n    admin_user = get_user(\"admin\")\n    if admin_user is None:\n        admin_password = os.environ.get(\"ADMIN_PASSWORD\")\n        if not admin_password:\n            logger.warning(\n                \"SEED_DEFAULT_USERS is set but ADMIN_PASSWORD is not provided. Skipping admin user creation to avoid insecure defaults.\"\n            )\n        else:\n            try:\n                create_user(\"admin\", admin_password, disabled=False)\n                logger.info(\"Default admin user created from environment variable.\")\n            except ValueError:\n                # If a race condition caused the admin to be created concurrently, ignore it.\n                logger.info(\"Admin user already exists; skipping creation.\")\n\n\n# Expose useful names for imports elsewhere\n__all__ = [\n    \"router\",\n    \"oauth2_scheme\",\n    \"get_current_user\",\n    \"get_current_active_user\",\n    \"create_access_token\",\n    \"User\",\n    \"UserInDB\",\n    \"Token\",\n]"}], "dependencies": ["fastapi", "sqlmodel", "uvicorn", "python-jose[cryptography]", "passlib[bcrypt]"]}